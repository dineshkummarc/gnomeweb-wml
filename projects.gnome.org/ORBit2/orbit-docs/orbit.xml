<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"docbook/xml-dtd-4.1.2-1.0-17/docbookx.dtd" [
<!--"docbook/xml-dtd-4.2-1.0-17/docbookx.dtd" [ --> 
<!-- "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [ -->
   <!ENTITY manrevision "1.6">
]> 

<book>
<bookinfo>
<title>ORBit Beginners Documentation V&manrevision;</title>
<authorgroup>
  <author>
    <firstname>Ewan</firstname><surname>Birney</surname>
  </author> 
  <author>
    <firstname>Michael</firstname><surname>Lausch</surname>
  </author>
  <author>
    <firstname>Todd</firstname><surname>Lewis</surname>
  </author>
  <author>
    <firstname>St&eacute;phane</firstname><surname>Genaud</surname>
  </author>
  <author>
    <firstname>Frank</firstname><surname>Rehberger</surname>
  </author>
</authorgroup>
<releaseinfo>
  Download page http://www.gnome.org/projects/ORBit2
  <ulink url="http://www.gnome.org/projects/ORBit2/orbit-docs.tar.gz">
    (TGZ)
  </ulink>
  <ulink url="http://www.gnome.org/projects/ORBit2/orbit-docs/orbit.pdf">
    (PDF)
  </ulink>
</releaseinfo>
<pubdate>2003</pubdate>
</bookinfo>

<toc></toc>

<!--
/******************************************************************/
/*                       Main Stuff                               */
/******************************************************************/
-->
<chapter>
<title>Introduction</title>
<para>
ORBit is an efficient, free C-based ORB, compliant to CORBA version 2.2.
CORBA stands for Common Object Request Broker Architecture. CORBA in many
ways is a successor to the Remote Procedure Call (RPC) system common on UNIX
and other systems: the best oneline description of CORBA is that it is
"Object Orientated RPC".</para>
<para>
The key point about CORBA is that it provides a way for two programs
to communicate information. The CORBA mechanism allows these two
programs to be running on <emphasis>different machines</emphasis> and written
in <emphasis>different programming</emphasis> languages while safely (and
portably) exchanging data. They also could be running in the same program, 
on the same machine, in which case the process of communication is much 
quickeras ORBit recognises that it does not need to open any communication channel.
</para>

<para>
ORBit has some important features which distinguish it from other
CORBA implementations. Firstly it is primarily a C-based
implementation (using the standard C mapping), which many other CORBA
implementations do not cater to. Secondly it is a fast
implementation, meaning that it moves information on and off the
communication channel into the programs quickly. Thirdly it is
efficient in terms of its memory usage, meaning it can be run on small
machines.  Fourthly it works, and works in real life problems. Finally
it is free software, that is free in terms of an open license to
change the source code. This means that a number of different people
(both academics and commerical people) can contribute to the source
code and that bugs and problems can be fixed quickly. ORBit
unsurprisingly is therefore licensed under the GNU Public License
(GPL). More information about how the terms of this license affect you
can be found in the FAQ, and you're encouraged to read the actual GPL
text that comes in the distribution
</para>

<para> The CORBA mechanism is ideal for classic client/server
applications, say a graphical client GUI communicating to a database
server, or much simpler applications, such as one program asking for a
mail service from the CORBA system. ORBit was made principly for the
latter case: that is communicating information between different
programs running in a desktop enviroment (the Gnome enviroment). ORBit
is a fully blown generic ORB and can be used in many other
applications outside of the gnome desktop - there is absolutely no
requirement to be running Gnome for ORBit.
</para> 
<para>
This documentation is aimed principly at getting people with C
programming experience started with ORBit and some discussion about
the challenges of writing ORB aware software. If you are a looking for
a more fluffy description about what CORBA is I would start at the
Resource section below.  If you want to know the technical
nitty-gritty about ORBit, go to the source code, or hang out on the
ORBit mailing list.
</para>
<para>
It is also hoped that this documentation will be a starting point for
a more technical orientated documentation about how ORBit is
structured and the internal functions. 
</para>
<sect1>
<title>About this documentation</title>
<para>
This documentation is currently maintained by Frank Rehberger 
<ulink url="mailto:frehberg@gnome.org" role="online">
frehberg@gnome.org
</ulink>.  
For the definitive guide about
what is going on, always go to the source code (with any luck, it will
have documentation) or the C mapping document at the OMG.  If you
think there is mistake with this documentation, please email me. If
you would like to contribute an example or another chapter, please
also get in contact, or post to the orbit mailing list.
</para>
<para>
This documentation was written with major contributions from Ewan Birney, Michael
Launsch and Todd Lewis, edited by St&eacute;phane Genaud, ORBit update 
by Frank Rehberger. It is written in docbook
<acronym>XML</acronym>. 
You can get :
<itemizedlist>
<listitem><para>
  The documentation and examples at
  <ulink url="http://www.gnome.org/projects/ORBit2/orbit-docs.tar.gz">
  http://www.gnome.org/projects/ORBit2/orbit-docs.tar.gz
  </ulink>
</para></listitem>

<listitem><para>
   A PostScript version of this document at 
  <ulink url="http://www.gnome.org/projects/ORBit2/orbit-docs/orbit.ps">
  http://www.gnome.org/projects/ORBit2/orbit-docs/orbit.ps
  </ulink>
  </para>
</listitem>
<listitem><para>
   A PDF version of this document at 
  <ulink url="http://www.gnome.org/projects/ORBit2/orbit-docs/orbit.pdf">
  http://www.gnome.org/projects/ORBit2/orbit-docs/orbit.pdf
  </ulink>
  </para>
</listitem>
</itemizedlist>
</para>

<sect2> 
<title>Change Notes between 1.5 and 1.4</title>
<para>
<itemizedlist>
   <listitem><para>New sample "threaded-calculator" uses POA-setup THREAD_PER_REQUEST now, demonstrating usage of policies for child POAs. Furtheron Makefile has changed: Linker merges  debug symbols of shared libraries correctly now into executable.</para></listitem>
</itemizedlist>
</para>
</sect2>

<sect2> 
<title>Change Notes between 1.4 and 1.3</title>
<para>
<itemizedlist>
   <listitem><para>Adding new sample "threaded-calculator" demonstrating usage of ORBit2 as background task.</para></listitem>
   <listitem><para>For all samples initialize ORB with string "orbit-local-mt-orb", this string is valid for current ORB and also for older releases.</para></listitem>

</itemizedlist>
</para>
</sect2>

<sect2> 
<title>Change Notes between 1.3 and 1.2</title>
<para>
<itemizedlist>
   <listitem><para>Port back to docbook4.1.2 used by gnome-doc project</para></listitem>
   <listitem><para>rename impl_*__destroy to impl_*__fini, being CORBA's nomenclature</para></listitem>
   <listitem><para>fix memory-leaks in server implementations: deactivate servants at termination</para></listitem>
</itemizedlist>
</para>
</sect2>

<sect2> 
<title>Change Notes between 1.2 and 1.1</title>
<para>
<itemizedlist>
   <listitem><para>Introduced section for change notes</para></listitem>
   <listitem><para>fixing __destroy __fini confusion</para></listitem>
   <listitem><para>Add chapter for sample codes byteseq, badcall and 
name-resolve</para></listitem>
</itemizedlist>
</para>
</sect2>

</sect1>
</chapter>


<!-- Chapter FAQ -->
<chapter>
<title>Frequently Asked Questions</title>
<para>This is to answer your questions about ORBit and Corba</para>
<sect1>
<title>General Questions</title>
<sect2>
<title>What is CORBA?</title>
<para>
CORBA stands for Common Object Request Broker Architecture,
standardized by the Object Management Group (OMG). It consists of an
Interface Definition Language (IDL), language bindings and protocols
to allow interoperation between applications
<itemizedlist>
   <listitem><para>written in different programming languages</para></listitem>
   <listitem><para>running in different processes</para></listitem>
   <listitem><para>developed for different operating systems</para></listitem>
</itemizedlist>

A more detailed answer to this question is available at
<ulink url="http://www.omg.org/gettingstarted/" role="online">
http://www.omg.org/gettingstarted
</ulink>
</para>
</sect2>

<sect2><title>What is ORBit?</title>
<para> ORBit is an implementation of CORBA, which is used (amongst
other things) in the GNOME project. Active development is done for
ORBit2, being a clean re-implementation from scratch. The old ORBit
code is no longer maintained. </para>
</sect2>

<sect2>
	<title>Why aren't you using ILU/MICO/TAO?</title> <para> Most
of GNOME is written in C, both for performance reasons, and because
C++ still isn't as portable and widely available. So integration with
CORBA should use the IDL C mapping, which rules out TAO and MICO. ILU
was ruled out because the license appeared as too restrictive at the
time for free software.  </para>
</sect2>

<sect2>
	<title>Is ORBit stable?</title>
<para>
ORBit is used in pretty much any GNOME application, which gives quite
some testing for the features used. Other features have seen little or
no testing.
</para>
</sect2>

<sect2>
	<title>Does ORBit work with other ORBs?</title>

<para>
Yes. This is one of the primary features of CORBA, and available
through the Internet Inter-ORB Protocol (IIOP). There is one pitfall:
ORBit has a proprietary security mechanism to authenticate clients. If
interoperability is desired then you might have to figure out a 
work-around for this.
</para>
</sect2>
<sect2>
	<title>What license does ORBit get distributed with and how does it affect me?</title>
	
<para>
The idl compiler is <emphasis>GNU Public licensed</emphasis> (
<acronym>GPL</acronym>).  The libaries are <emphasis>Library
GPL</emphasis> (<acronym>L-GPL</acronym>) licensed. The code generated
from the idl compiler have no restriction. Bascially this means you
can use ORBit in your own applications (including proprietary
applications), the only restriction being that people whom you
distribute your working code to must be able to update the ORBit
libraries at will.  If you wish to modify and distribute the ORBit idl
compiler you have to distribute that modification under the GPL.
</para>

</sect2>
<sect2>
	<title>Why doesn't ORBit compile with my cc compiler ?</title>
<para>
ORBit uses some of the extensions that gcc allows, including
assignment to casts and void * pointer arithmetic. More current versions
of ORBit will remove these and eventually it is likely the ORBit will
compile with all ANSI C compilers.
</para>
<para>
You can always install gcc and use that. This will always work.
</para>
</sect2>

<sect2>
	<title>What is a language binding?</title>

<para>
A language binding defines how to use the IDL operations in a
programming language. There is a client-side mapping which explains
how to call operations, and a server-side mapping which defines how to
implement them. The client side mapping is largely
implementation-independent.
</para>
<para>
On the server side, different 'object adapters' are provided by ORB
vendors; only the 'Portable Object Adapter' (POA) implemented by ORBit
allows portability between CORBA implementations.
</para>
</sect2>
<sect2>
	<title>What language bindings does ORBit provide?</title>
<para>
At the moment only the C binding. Python and Perl bindings are being
seriously talked about. Bindings (in various degrees of completeness)
are also available for C++, Lisp, Pascal, Python, Ruby, and TCL; others are in-progress.
</para></sect2>
<sect2>
	<title>Does ORBit have DII and DSI?</title>

<para>
Yes. Though beware that using DII and DSI in some cases requires
the use of dynAny, which is not supported yet.
</para>
</sect2>
<!-- FIXME -->
<!--<sect2>
	<title>Does ORBit provide an interface repository?</title>

<para>
Yes, but non that would be compliant to CORBA-2.x. 
</para> 

</sect2> -->
<sect2>
	<title>Does ORBit provide a naming service?</title>
<para>
Yes. In addition, it is possible to use a third-party naming service,
e.g. using the --ORBNamingIOR command line option. The 'Interoperable
Naming' specification is not yet supported.
</para>
</sect2>

<sect2>
	<title>Can you encrypt a CORBA connection?</title>

<para>
Yes, ORBit supports IIOP over SSL. the implementation is based on
OpenSSL and support client and server side authentication.  Frank
O'Dwyer did initial work on this for ORBit.  </para> </sect2>

</sect1>

<sect1>
	<title>Common Coding Problems</title>
<sect2>
	<title>LD_LIBRARY_PATH not defined</title>
<para>	
ORBit uses dynamically loadable libraries and these need
to be on the LD_LIBRARY_PATH for things to work.</para>
</sect2>

<sect2>
<title>IOR strings with newlines</title>
<para>When you get an object using a stringified IOR, make sure
you trim the trailing newline from the string before passing
it on.</para>
</sect2>

<sect2>
<title>Activating POAManager before servants can handle requests</title>
<para>
You must activate the POAManager before incoming requests can
be processed

<programlisting>
PortableServer_POAManager_activate(PortableServer_POA__get_the_POAManager(poa,&amp;ev),&amp;ev)
</programlisting>
</para>


</sect2>
<!-- How do I connect to NameService? -->

</sect1>
</chapter>

<!-- /*********** Installing ORBit ***********************/ -->
<chapter>
<title>Installing ORBit</title>
<sect1>
<title>Installing from RPMS</title> 
  
  <para>
  The RPMs can be found on many web sites. 
  The whole ORBit package is broken in two parts (as for most RPMs) : 
  the <filename>ORBit2</filename> package contains the libraries to use it, and
  the <filename>ORBit2-devel</filename> package contains the necessary files to develop
  with ORBit, i.e. the idl compiler and the headers files.
  </para>
  <para>
  I recommend the RPM repositories like <ulink url="http://www.rpmfind.org">http://www.rpmfind.org</ulink>
  to find the RPMS that best suit your distribution. Though ORBit is probably installed if you already
  have GNOME installed, you must download the <filename>ORBit-devel</filename> to develop with ORBit.
  </para>
  <para>
  Installation is quite simple : once the packages are downloaded, go:
  <screen>
  <prompt>bash $ </prompt><userinput>rpm -Uvh ORBit2* ORBit2-devel*</userinput>
  </screen>
  Note that this will upgrade any previous rpm-based installation of ORBit.
  </para>
 
</sect1>
<sect1>
  <title>Installing from Source</title>
<para>

Installing from ORBit2 source code is very easy. You need to have glib
version 2.0.0 or later series installed. To see if you have
glib installed (and what version) go <command> glib-config
--version</command>
</para>
<para>
You can obtain the latest version of glib from http://www.gtk.org/
</para>
<para>
Now just download the latest stable tar ball of ORBit. Start by
going to the gnome web site (http://www.gnome.org/), choose
download and find your closest mirror site. 
</para>
<para>
ORBit installs as a standard gnu application, so going
<userinput>./configure </userinput> followed by <userinput> make </userinput>
and then getting root permissions and <userinput> make install </userinput>
will do everything as expected.
</para>
<para>
<emphasis>What to do if you don't have root permissions</emphasis>

Basically you want to run all of the above but with
<userinput>./configure --prefix=&lt;installation location&gt; </userinput> which
will install under <emphasis>prefix</emphasis>/bin /libs etc.
</para>
<para>
If ORBit2 2.7 does not compile with some commercial C compilers, this is
because it uses a number of gcc extensions which are not supported elsewhere.
<emphasis>you can always download gcc and install that</emphasis> for it to work.
</para>


</sect1>
<sect1>
  <title>Getting the examples to run</title>
<para>Once you have successfully installed orbit, getting the examples to
run should be fine. 
The examples are available by http from 
  <ulink url="http://www.gnome.org/projects/ORBit2/orbit-docs.tar.gz">
  http://www.gnome.org/projects/ORBit2/orbit-docs.tar.gz
  </ulink>
Gunzip and untar the package, perhaps like:
<screen>
<prompt>bash $</prompt><userinput>gunzip -c orbit-docs.tar.gz | tar -xvf -</userinput>
</screen>

This should build a documentation directory that contains this
documentation in both sgml (docbook) and html, and an examples
directory. Move to the examples directory, and go

<screen>
<prompt>bash $</prompt><userinput>./configure</userinput>
<prompt>bash $</prompt><userinput>cd echo</userinput>
<prompt>bash $</prompt><userinput>make</userinput>
</screen>

Proceed similarly for the calculator example.
</para>

<para>
To actually run the echo example, open two windows up. 
Run <filename>echo-server</filename> in one and 
<filename>echo-client</filename> in the other 
(echo-server writes out the file <filename>echo.ref</filename> which echo-client reads).

If you want to have fun now, compile
orbit on a different machine, make echo-client on the different machine,
move <filename> echo.ref </filename> from the first machine to the second and run echo-client:
eh voila - client/server over tcp/ip with the same code that ran using
unix sockets on a single machine.
</para>
<note>
<para>
From ORBit 0.5.3, IIOP communications over IP sockets are disabled by default for security
reasons. You should create
an <filename> /etc/orbitrc </filename> (for a system-wide settings), 
or an <filename> ~/.orbitrc </filename> (for one user's setting) containing something like :
<programlisting>
ORBIIOPUSock=1
ORBIIOPIPv4=1
ORBIIOPIPv6=0
</programlisting>
Alternatively, you can also use command line parameters.
</para>
</note>


</sect1>
<sect1>
<title>Known platforms where ORBit works</title>
<para>
ORBit in theory is portable to any UNIX system (using the
GNU configure system to define the system). Try it out - it
will probably work. However, you may want to see if your
platform has definitely been used before
</para>
<itemizedlist>
<listitem><para>GNU/Linux, i386 Redhat/SuSE/Debian distributions</para></listitem>
<listitem><para>GNU/Linux, alpha</para></listitem>
<listitem><para>GNU/Linux, sparc</para></listitem>
<listitem><para>Solaris 2.6 (UltraSparc) </para></listitem>
<listitem><para>Digital UNIX 4.0</para></listitem>
<listitem><para>FreeBSD 2.2.7-RELEASE (Intel)</para></listitem>
<listitem><para>IRIX 6.2 (you can get it from <ulink url="http://freeware.sgi.com">http://freeware.sgi.com</ulink>)</para> 
</listitem>

</itemizedlist>
<para>If you manage to compile it on any other platforms, let me know.</para> 
</sect1>
</chapter>
<chapter><title>CORBA concepts</title>
<para>
Please skip this chapter and head straight to the first examples if
you are the sort of person who understands better just by example. 
The examples chapter can be read without reading this chapter.
</para>
<para>
This chapter is to help you get an understanding of all the different
terms that are bandied about ORBs and CORBA.
</para>
<para>
CORBA is a collection of standards defined by the Object Management Group
(OMG - the sole purpose of the OMG is to provide a framework for people
to agree on standards for CORBA). The OMG does not provide any working
implementations of the CORBA standards, and so can be impartial.
Most people who use CORBA only really
keep one or two of these standards in their heads, but all the standards
are free to be read from the OMG web site 
<ulink url="http://www.omg.org/">
http://www.omg.org/
</ulink>.
However it is good to have an idea about how all these standards fit
together to provide CORBA.
</para>
<sect1>
<title>Quick tour of a working client&amp;server</title>
<para>
The basic mechanism of CORBA is to run a method (that is a function) of an
object from a separate program (in fact the program need not be separate,
but don't worry about that yet). Going from one end of this to the other,
this is what needs to be defined.
</para>
<sect2>
<title>Definition of the object - the IDL</title>
<para>
A definition of what methods can be called on what objects need to be
provided for both the caller and callee. This is done using the 
<emphasis> Interface Definition Language </emphasis> or <acronym> IDL </acronym> of the object.
The only information which is required to make a caller able to call an
object on a remote server is the IDL of the object. Everything else is
handled by the standards defined by the OMG.
</para>
</sect2>
<sect2>
<title>Identifying the Object</title>

<para>The calling program needs to identify the (possibly remote)
object somehow. This is done by something called an
<emphasis>IOR</emphasis>, which can be represented as a string, and
therefore used as an argument in the program.  Decoding the IOR the
client can tell the CORBA protocol and character encoding the server
supports, beside much more details.</para>
<!-- FIXME, words about corbaloc -->

</sect2>
<sect2>
<title>Calling the method</title>
<para>
The calling program needs to actually call the method on the object somehow.
This is done in the programming language of the caller, and the way
the IDL of the maps to the programming language is standardised by the OMG.
This is called the <emphasis>Language Mapping</emphasis>, and all the different
ORBs provide at least one mapping. ORBit provides at the moment a C mapping.
</para>
<para>
Of course, C is a compiled language, so to write a C program which is going
to make an ORBit call, one needs to compile the IDL of the object one wants
to access using the orbit-idl compiler, and then write a C program which
call functions that the orbit-idl compiler defines, compile this user written
code along with the code generated for the client by the orbit compiler,
and link it to the orbit and network libraries.
</para>
<para>
However for more dynamic languages (eg, Python), a more natural way of
using CORBA is to dynamically load in the IDL definition and use it without
any separate compile phase. The beauty of CORBA is that it supports both
mechanisms
</para>
</sect2>
<sect2>
<title>Moving the call across the network</title>
<para>
The function call on the client now gets handled by the <emphasis>Object Request
Broker</emphasis> or <emphasis>ORB</emphasis> and gets translated to the actual TCP/IP
request to the server <emphasis>ORB</emphasis> which is handling the object to be
called. The two ORBs communicate via a protocol called the 
<emphasis>Internet InterOrb Protocol</emphasis> or <emphasis>IIOP</emphasis>, which is
standard. This means that the ORBs could come from different suppliers,
and never had been tested against each other, and yet still work. 
</para>
</sect2>
<sect2>
<title>Returning the answer</title>
<para>
On the server side, a mirror of the client process happens, translating the
request from TCP/IP packets to an actual call in the programming language
used to write the server. The servant object, written by whoever wrote
the server then provides the return values, and the results are sent 
back down the ORBs to the client in reply message.
</para>
</sect2>
<sect2><title>Continue</title>
<para>
This may seem like a lot of work for a rather simple thing, but the idea
about having so many standards is that some of the standards can change
and adapt without everything in CORBA shifting. Learning about CORBA is
usually much easier by example, so I would dip into the next chapter 
and come back to this one later.
</para></sect2>
</sect1>



</chapter>
<chapter id="first-programs">
<title>First CORBA Programs</title>
<sect1>
<title>Examples introduction</title>
<para>
Three different, working programs will be presented in 
this chapter. They are all very simple and worth looking
over and running (you will find the source code for them
in the examples directory that comes with orbit-docs.tar.gz)
</para>
<para>
I have tested out the first two examples, echo and calculator and
they work from the code in this document. The actual code with makefiles
can be found at 
<ulink url="http://www.gnome.org/projects/ORBit2/orbit-docs.tar.gz">
http://www.gnome.org/projects/ORBit2/orbit-docs.tar.gz
</ulink>.
However, it is likely that the code is not is well written as we would like,
and I am sure it could get better. Please drop me a note if you would like
to contribute something to the examples, preferably as patches to the code
in examples directory and the orbit.xml document.
</para>
</sect1>
<sect1>
<title>Files at a glance</title>
<para>
Before we present these examples, we should sketch what files are generated
or written by the programmer in a typical ORBit application. 
The load of files generated from the IDL specification may seem very complex at a first glance,
and the following table tries to make clearer which files are really important.

The first file the programmer must write in an ORBit application,
is the IDL file. 
For a <filename> f.idl </filename> IDL specification, running
<screen>
<prompt>bash $</prompt><userinput>orbit-idl-2 --skeleton-impl f.idl</userinput>
</screen>

will produce most of the needed files to start writing the application (you can see it as a framework).
They are listed in the following table:
<informaltable>
<tgroup cols="2">
<thead>
<row>
<entry>File</entry><entry>Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry>f-stubs.c</entry><entry>do not edit (translation of your IDL)</entry>
</row>
<row>
<entry>f-skels.c</entry><entry>do not edit (translation of your IDL)</entry>
</row>
<row>
<entry>f-common.c</entry><entry>do not edit (generated from IDL)</entry>
</row>
<row>
<entry>f.h</entry><entry>do not edit</entry>
</row>
<row><entry>f-skelimpl.c</entry><entry>add the code of the server methods</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Files remaining to write :
<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>f-client.c</entry><entry>write the client code</entry>
</row>
<row>
<entry>f-server.c</entry><entry>write the generic code for servant creation</entry>
</row>
</tbody></tgroup></informaltable>

</para>

<para>
The first three files deal with communication implementation and are
automatically generated from your IDL file. 
The <filename> f-skelimpl.c </filename> file contains the framework
of the servant functions: you should find near the end of the file,
function prototypes corresponding to the one you have declared in
your IDL, your real code must be inserted between markers.
Of course, you should keep this file only on the server side since
it is of no use for the client.
</para>
<para>
The <filename> f-client.c </filename> (you can choose another name)
is to be written by the programmer. This is where the programmer
initializes the ORB and binds the client to the server using the IOR.
</para>
<para>
The <filename> f-server.c </filename> (you can choose another name)
must also be written but this part is rather generic and is usually
copied from an existing application and hardly ever modified during the application
developpement. 
It always deals with the ORB initialization and the 
POA creation so that servants are spawned to execute the server code
defined in <filename> f-skelimpl.c </filename>.

</para>
</sect1>
<sect1>
<title>Echo client &amp; server</title>
<para>
The aim for this example is to run a client which accepts typed
input and this is printed out on the server on stdout
</para>
<para>
The echo functionality is represented in the following very
short IDL.
<example>
<title>Echo IDL file</title>

<programlisting role="IDL">

// MyFirstOrbit program - The Echo object
//
// All this does is pass a string from the
// client to the server.

interface Echo {
	void echoString(in string input);
};
</programlisting>
</example>
</para>
<para>
The <emphasis>interface</emphasis> definition is the key part of the 
definition. Each interface defines an object which can have methods
on it. In this case there is one method, which takes a string
argument and returns nothing. The <emphasis>in</emphasis> declaration before
the argument indicates that this arguments is only passed into the
method. Generally all arguments are in arguments, for the first
case.
</para>
<para>
This idl is found in the file <filename>echo.idl</filename>. 
To compile the idl one does the following step:
<computeroutput>
$ <command>orbit-idl-2 --skeleton-impl echo.idl</command>
</computeroutput>
which will produce most of the needed files to start writing the <emphasis>echo</emphasis> application (you can see it as a framework).
They are listed in the following table:

<informaltable>
<tgroup cols="3">
<colspec align="left"/>
<colspec align="center"/>
<colspec align="center"/>
<thead>
<row>
<entry>File</entry><entry>Usage for Client</entry><entry>Usage for Server</entry>
</row>
</thead>
<tbody>
<row>
<entry>echo.h</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>echo-common.c</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>echo-stubs.c</entry><entry>readonly</entry><entry>-</entry>
</row>

<row>
<entry>echo-skels.c</entry><entry>-</entry><entry>readonly</entry>
</row>
<row><entry>echo-skelimpl.c</entry><entry>-</entry><entry>template for user code</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Files remaining to write are listed in following table, starting with 
<emphasis>echo-client.c</emphasis> in following chapter.
<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>echo-client.c</entry><entry>write the client code</entry>
</row>
<row>
<entry>echo-server.c</entry><entry>write the generic code for servant creation</entry>
</row>
</tbody></tgroup>
</informaltable>

</para>


<sect2>
	<title>Echo client</title>
<para>	
The client code is shown here
<example>
<title>echo-client.c</title>
<programlisting role="C">/*
 * Echo client program.. Hacked by Ewan Birney &lt;birney@sanger.ac.uk&gt;
 * from echo test suite, update for ORBit2 by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;
 *
 * Client reads object reference (IOR) from local file 'echo.ref' and
 * forwards console input to echo-server. A dot . as single character
 * in input terminates the client.
 */

#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
<command>#include &lt;orbit/orbit.h&gt;</command>

/*
 * This header file was generated from the idl
 */

<command>#include "echo.h"</command>

/** 
 * test for exception 
 */
static
gboolean 
raised_exception(CORBA_Environment *ev) 
{
	return ((ev)->_major != CORBA_NO_EXCEPTION);
}

/**
 * in case of any exception this macro will abort the process  
 */
static
void 
abort_if_exception(CORBA_Environment *ev, const char* mesg) 
{
	if (raised_exception (ev)) {
		g_error ("%s %s", mesg, CORBA_exception_id (ev));
		CORBA_exception_free (ev); 
		abort(); 
	}
}

static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
 
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
client_shutdown (int sig)
{
        CORBA_Environment  local_ev[1];
        CORBA_exception_init(local_ev);
 
        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</command>
                abort_if_exception (local_ev, "caught exception");
        }
}
 
        
/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_client_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */
static
void
client_init (int               *argc_ptr,
	     char              *argv[],
             CORBA_ORB         *orb,
             CORBA_Environment *ev)
{
        /* init signal handling */
 
        signal(SIGINT,  client_shutdown);
        signal(SIGTERM, client_shutdown);
         
        /* create Object Request Broker (ORB) */
         
        <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev);</command>
        if (raised_exception(ev)) return;
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static
void
client_cleanup (CORBA_ORB                 orb,
                CORBA_Object              service,
                CORBA_Environment        *ev)
{
        /* releasing managed object */
        <command>CORBA_Object_release(service, ev);</command>
        if (raised_exception(ev)) return;
 
        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                <command>CORBA_ORB_destroy(orb, ev);</command>
                if (raised_exception(ev)) return;
        }
}

/**
 *
 */
static
CORBA_Object
client_import_service_from_stream (CORBA_ORB          orb,
				   FILE              *stream,
				   CORBA_Environment *ev)
{
	CORBA_Object obj = CORBA_OBJECT_NIL;
	gchar *objref=NULL;
    
	fscanf (stream, "%as", &amp;objref);  /* FIXME, handle input error */ 
	
	obj = (CORBA_Object) CORBA_ORB_string_to_object (global_orb,
							 objref, 
							 ev);
	free (objref);
	
	return obj;
}

/**
 *
 */
static
CORBA_Object
client_import_service_from_file (CORBA_ORB          orb,
				 char              *filename,
				 CORBA_Environment *ev)
{
        CORBA_Object  obj    = NULL;
        FILE         *file   = NULL;
 
        /* write objref to file */
         
        if ((file=fopen(filename, "r"))==NULL)
                g_error ("could not open %s\n", filename);
    
	obj=client_import_service_from_stream (orb, file, ev);
	
	fclose (file);

	return obj;
}


/**
 *
 */
static
void
client_run (Echo  echo_service,
	    CORBA_Environment        *ev)
{
	char filebuffer[1024+1];

	g_print("Type messages to the server\n"
		"a single dot in line will terminate input\n");
	
	while( fgets(filebuffer,1024,stdin) ) {
		if( filebuffer[0] == '.' &amp;&amp; filebuffer[1] == '\n' ) 
			break;
		
		/* chop the newline off */
		filebuffer[strlen(filebuffer)-1] = '\0';
      
		/* using the echoString method in the Echo object 
		 * this is defined in the echo.h header, compiled from
		 * echo.idl */

		<command>Echo_echoString(echo_service,filebuffer,ev);</command>
		if (raised_exception (ev)) return;
	}
}

/*
 * main 
 */
int
main(int argc, char* argv[])
{
	CORBA_char filename[] = "echo.ref";
        
	Echo echo_service = CORBA_OBJECT_NIL;

        CORBA_Environment ev[1];
        <command>CORBA_exception_init(ev);</command>

	<command>client_init (&amp;argc, argv, &amp;global_orb, ev);</command>
	abort_if_exception(ev, "init failed");

	g_print ("Reading service reference from file \"%s\"\n", filename);

	<command>echo_service = (Echo) client_import_service_from_file (global_orb,
							       "echo.ref",
							       ev);</command>
        abort_if_exception(ev, "import service failed");

	<command>client_run (echo_service, ev);</command>
        abort_if_exception(ev, "service not reachable");
 
	<command>client_cleanup (global_orb, echo_service, ev);</command>
        abort_if_exception(ev, "cleanup failed");
 
        exit (0);
}
</programlisting>
</example>


The client can be broken down into three distinct sections.
<itemizedlist>
<listitem> <para>Initialising the ORB </para></listitem>
<listitem><para> Getting the Object </para></listitem>
<listitem> <para>Using the Object </para></listitem>
</itemizedlist>
The key part of the client is when it calls the echoString method on
the server. The idl definition
<programlisting role="IDL">
     void echoString(in string input);
</programlisting>
Ends up becoming the following definition in the echo.h header
file generated from the idl
<programlisting role="C">
extern void Echo_echoString(Echo               obj, 
                            CORBA_char        *astring, 
                            CORBA_Environment *ev);
</programlisting>
This follows the accepted rules for Object based programming in C, that is
<itemizedlist>
<listitem><para>
   The Object is passed in as the first argument to the function </para></listitem>
<listitem><para>
   The method name is qualified by the object name beforehand</para></listitem>
<listitem><para>Exceptions are handled by a structure that is passed in as the last argument to the function</para> </listitem>
</itemizedlist>
Of course, you don't have to follow this in your own code, but this is how
the CORBA C mapping works, and it is not a bad solution.
</para>
</sect2>
<sect2>
<title>Echo Server</title>
<para>
The server is basically more complicated than the client, but has some
commonality with the client. The server has to at the end of the day 
go into a main loop where it listens to connections. Before that it has
to create the ORB and bind its own implementations of the objects to 
the ORB.
</para>
<para>
In real life servers, this gets much more complicated, but as this is
an example, it is pretty simple once you get through the ORB initialisation
process.
</para>

<example>
<title>echo-server.c source code</title>
<programlisting role="C">/*
 * echo-server program. Hacked from Echo test suite by
 * &lt;birney@sanger.ac.uk&gt;, ORBit2 udpate by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "echo-skelimpl.c"
#include "examples-toolkit.h" /* provides etk_abort_if_exception */ 

static CORBA_ORB          global_orb = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA root_poa   = CORBA_OBJECT_NIL; /* root POA
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGINT,  server_shutdown);
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

         <command>(*poa) = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;

         <command>poa_manager = PortableServer_POA__get_the_POAManager(*poa, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

	 <command>PortableServer_POAManager_activate(poa_manager, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

         <command>CORBA_Object_release ((CORBA_Object) poa_manager, ev); </command>
	return;

 failed_activation:
 failed_poamanager:
        CORBA_Object_release ((CORBA_Object) poa_manager, local_ev);
 failed_poa:
	CORBA_ORB_destroy(*orb, local_ev);		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
         <command>CORBA_ORB_run(orb, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	 <command>objid = PortableServer_POA_reference_to_id (poa, ref, ev); </command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	 <command>PortableServer_POA_deactivate_object (poa, objid, ev); </command>
	if (etk_raised_exception(ev)) return;

	 <command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev); </command>
	if (etk_raised_exception(ev)) return;

	CORBA_free (objid);

         <command>CORBA_Object_release ((CORBA_Object) poa, ev); </command>
	if (etk_raised_exception(ev)) return;
	
         <command>CORBA_Object_release (ref, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Echo  ref = CORBA_OBJECT_NIL; 

	 <command>ref = impl_Echo__create (poa, ev); </command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	CORBA_Object servant = CORBA_OBJECT_NIL;
	
	CORBA_char filename[] = "echo.ref";

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	 <command>server_init (&amp;argc, argv, &amp;global_orb, &amp;root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed ORB init");

	 <command>servant = server_activate_service (global_orb, root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Writing service reference to: %s\n\n", filename);

	 <command>etk_export_object_to_file (global_orb, 
				   servant, 
				   filename, 
				   ev); </command>
	etk_abort_if_exception(ev, "failed exporting IOR");
	
	 <command>server_run (global_orb, ev); </command>
	etk_abort_if_exception(ev, "failed entering main loop");

	 <command>server_cleanup (global_orb, root_poa, servant, ev); </command>
	etk_abort_if_exception(ev, "failed cleanup");

	exit (0);
}
	

</programlisting>
</example>

<para>
The key part of the server is when it calls <command>servant =
impl_Echo__create (poa, ev);</command>. This is a function defined in
file <filename>echo-skelimpl.c</filename> being included at top of
echo-server.c. For each object method of echo object interface file
<filename>echo-skelimpl.c</filename> contains a predefined
implementation that must be extended by user (specific regions are
marked by comments); incoming requests are delegated by object manager
to specific method implementation. - For echo server application only
a single line for method <command>echoString(..)</command> must be
inserted, this line will print the echo-string to console. Let's have
a look at <filename>echo-skelimpl.c</filename> that has been generated
by <command>orbit-idl-2</command> tool as template for user. Therefor
only a single line has been added by user <command>g_print ("%s\n",
input);</command> at very end of file in function body
<emphasis>impl_Echo_echoString(..)</emphasis>.</para>
<note><para>Constructor (__create) and Destructor (__fini) are defined,
too. How to extend those functions defining lifecycle of objects will
be subject to next chapters.</para></note>

<example>
<title>echo-skelimpl.c</title>
<programlisting role="C">#include "echo.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Echo servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */
   /* ------ ---------- end ------------ ------ */
}
impl_POA_Echo;

/*** Implementation stub prototypes ***/

static void impl_Echo__fini(impl_POA_Echo * servant,
			       CORBA_Environment * ev);
static void
impl_Echo_echoString(impl_POA_Echo * servant,
		     const CORBA_char * input, CORBA_Environment * ev);

/*** epv structures ***/

static PortableServer_ServantBase__epv impl_Echo_base_epv = {
   NULL,			/* _private data */
   (gpointer) &amp;amp; impl_Echo__fini,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Echo__epv impl_Echo_epv = {
   NULL,			/* _private */
   (gpointer) &amp; impl_Echo_echoString,

};

/*** vepv structures ***/

static POA_Echo__vepv impl_Echo_vepv = {
   &amp;impl_Echo_base_epv,
   &amp;impl_Echo_epv,
};

/*** Stub implementations ***/

static Echo
impl_Echo__create(PortableServer_POA poa, CORBA_Environment * ev)
{
   Echo retval;
   impl_POA_Echo *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Echo, 1);
   newservant->servant.vepv = &amp;impl_Echo_vepv;
   newservant->poa =     
      (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object) poa, ev);
   POA_Echo__init((PortableServer_Servant) newservant, ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

static void
impl_Echo__fini(impl_POA_Echo * servant, CORBA_Environment * ev)
{
    <command>CORBA_Object_release((CORBA_Object) servant->poa, ev); </command>
 
   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   POA_Echo__fini((PortableServer_Servant) servant, ev);

   g_free(servant);
}

static void
impl_Echo_echoString(impl_POA_Echo * servant,
		     const CORBA_char * input, CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   <command>g_print ("%s\n", input); </command>
   /* ------ ---------- end ------------ ------ */
}</programlisting>
</example>
</sect2>

<sect2 id="echo-compilation"> <title>Compiling  server &amp; client</title>

<para> The following
makefile can be used to compile both, the client and the server. Be
aware of the location of ORBit : on my system it has been installed
under /usr but it could be /usr/local if you have built it from the
sources, and hence the path for ORBIT variables below may vary. If
using ORBit binary packages shipped with your Linux or BSD/Unix
distribution the makefile below will do.

<example> 
<title>Makefile</title>
<programlisting role="make">
PREFIX ?= /usr
CC = gcc
TARGETS=echo-client echo-server
ORBIT_IDL=orbit-idl-2
CFLAGS=-g -DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
       -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
       -I$(PREFIX)/lib/glib-2.0/include
LDFLAGS= -Wl,--export-dynamic -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm
IDLOUT=echo-common.c echo-stubs.c echo-skels.c echo.h
 
all: $(IDLOUT) echo-client echo-server
 
echo-server.o : echo-server.c echo-skelimpl.c 

echo-client : echo-client.o echo-common.o echo-stubs.o
echo-server : echo-server.o echo-common.o echo-skels.o
 
$(IDLOUT): echo.idl
        $(ORBIT_IDL) echo.idl
 
clean:
        rm -rf *.o *~ $(IDLOUT)
 
distclean: clean
        rm -rf echo-client echo-server</programlisting>
</example> 
</para>

<example><title>Invoking make</title> 
<screen width="80">
<prompt>[frehberg@papaya echo]$ </prompt><userinput>make</userinput>
orbit-idl-2 echo.idl
orbit-idl-2 2.4.1 compiling
 small mode, show preprocessor errors, passes: stubs skels common headers 
 skel_impl imodule

gcc -DORBIT2=1 -D_REENTRANT -I/usr/include/orbit-2.0 -I/usr/include/linc-1.0 
-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include   -c -o echo-client.o   
echo-client.c
gcc -DORBIT2=1 -D_REENTRANT -I/usr/include/orbit-2.0 -I/usr/include/linc-1.0 
-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include   -c -o echo-common.o   
echo-common.c
gcc -DORBIT2=1 -D_REENTRANT -I/usr/include/orbit-2.0 -I/usr/include/linc-1.0 
-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include   -c -o echo-stubs.o     
echo-stubs.c
gcc -Wl,--export-dynamic -lORBit-2 -llinc -lgmodule-2.0 -ldl -lgobject-2.0   
-lgthread-2.0 -lpthread -lglib-2.0 -lm  echo-client.o echo-common.o          
echo-stubs.o   -o echo-client
gcc -DORBIT2=1 -D_REENTRANT -I/usr/include/orbit-2.0 -I/usr/include/linc-1.0 
-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include   -c -o echo-server.o    
echo-server.c
gcc -DORBIT2=1 -D_REENTRANT -I/usr/include/orbit-2.0 -I/usr/include/linc-1.0 
-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include   -c -o echo-skels.o     
echo-skels.c
gcc -Wl,--export-dynamic -lORBit-2 -llinc -lgmodule-2.0 -ldl -lgobject-2.0  
-lgthread-2.0 -lpthread -lglib-2.0 -lm  echo-server.o echo-common.o          
echo-skels.o   -o echo-server</screen>
</example>

<para>
After calling <command>make</command> in terminal window all sources
have been compiled and you should open a second terminal window. In
the first window we will start the server with the command:
<command>./echo-server</command>. The server should print a very long
string into the file <filename>echo.ref</filename>, starting with the
4 character sequence <computeroutput>IOR:</computeroutput> In the
second window we will print content of <filename>echo.ref</filename>
to console and start the client with the command
<command>./echo-client</command>. You should not try to type the IOR
string, instead use the cut and paste functionality of your terminal.
</para>

<example>
<title>Terminal 1 - Starting Echo Server</title>
<screen width="80">
<prompt>[frehberg@papaya echo]$ </prompt><userinput>./echo-server</userinput>
</screen>
</example>

<example>
<title>Terminal 2 - Starting Echo Client</title>
<screen width="80">
<prompt>[frehberg@papaya echo]$ </prompt><userinput>cat echo.ref</userinput>
IOR:010000000d00000049444c3a4563686f3a312e3000000000030000000054424f540000000101
020005000000554e4958000000000700000070617061796100002e0000002f746d702f6f72626974
2d66726568626572672f6c696e632d323230662d302d323532356663323537306430340000000000
0000caaedfba58000000010102002e0000002f746d702f6f726269742d66726568626572672f6c69
6e632d323230662d302d323532356663323537306430340000001c00000000000000a6361450d7ea
e8a8dc29282828282828010000008af91bdf01000000480000000100000002000000050000001c00
000000000000a6361450d7eae8a8dc29282828282828010000008af91bdf01000000140000000100
000001000105000000000901010000000000
<prompt>[frehberg@papaya echo]$ </prompt><userinput>./echo-client</userinput>
Type messages to the server
a single dot in line will terminate input:
</screen>
</example>
</sect2>

</sect1>
   
<sect1 id="calculator-IDL">
      <title>Calculator client &amp; server</title>
      <para>
This example will take you further into understanding how to actually
make a working server, using the support that comes from ORBit. It
will demonstrate handling of replies from server.
</para>
      <para>

The system will not be doing very much. The server just provides two
functions, one to add two numbers and one to subtract two numbers. The
first thing you have to do is to write the IDL files for the
server. In our example it is very simple.
<example>
	  <title>calculator.idl</title>
	  <programlisting role="IDL">

interface Calculator
{
      double add(in double number1, in double number2);
      double sub(in double number1, in double number2);
};

</programlisting>
	</example>

Then you have to generate the skeleton and stub files. In addition to
these two files the ORBit IDL compiler also generates a common file
and a header file. The common file implements the memory management
functions and other things, useful in the client as well as in the
server. The sequence to generate the C source files is rather
simple.
<computeroutput>$ <command>orbit-idl-2 --skeleton-impl
calculator.idl</command>
</computeroutput>
geenrates all the files we will use in this example.

<informaltable>
<tgroup cols="3">
<colspec align="left"/>
<colspec align="center"/>
<colspec align="center"/>
<thead>
<row>
<entry>File</entry><entry>Usage for Client</entry><entry>Usage for Server</entry>
</row>
</thead>
<tbody>
<row>
<entry>calculator.h</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>calculator-common.c</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>calculator-stubs.c</entry><entry>readonly</entry><entry>-</entry>
</row>

<row>
<entry>calculator-skels.c</entry><entry>-</entry><entry>readonly</entry>
</row>
<row><entry>calculator-skelimpl.c</entry><entry>-</entry><entry>template for user code</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Files remaining to write are listed in following table, starting with 
<emphasis>calculator-client.c</emphasis> in following chapter.
<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>calculator-client.c</entry><entry>write the client code</entry>
</row>
<row>
<entry>calculator-server.c</entry><entry>write the generic code for servant creation</entry>
</row>
</tbody></tgroup>
</informaltable>


</para>
      <sect2 id="calculator-client">
      <title>Calculator client</title>
<para>
The next thing you have to do is to write the server and client
programs. We start with the client, because it's easier and not very
complicated. 
</para>
<para>
  A simple implementation of the client might look like this
  <example>
	  <title>calculator-client.c</title>
	    <programlisting role="C">/* calculator-client.c hacked by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.  */

#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "calculator.h"

#include "examples-toolkit.h"

static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
 
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
client_shutdown (int sig)
{
        CORBA_Environment  local_ev[1];
        CORBA_exception_init(local_ev);
 
        if (global_orb != CORBA_OBJECT_NIL)
        {
                 <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}
 
        
/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_client_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */
static
void
client_init (int               *argc_ptr,
	     char              *argv[],
             CORBA_ORB         *orb,
             CORBA_Environment *ev)
{
        /* init signal handling */
 
        signal(SIGINT,  client_shutdown);
        signal(SIGTERM, client_shutdown);
         
        /* create Object Request Broker (ORB) */
         
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
        if (etk_raised_exception(ev)) return;
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static
void
client_cleanup (CORBA_ORB                 orb,
                CORBA_Object              service,
                CORBA_Environment        *ev)
{
        /* releasing managed object */
         <command>CORBA_Object_release(service, ev); </command>
        if (etk_raised_exception(ev)) return;
 
        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
                if (etk_raised_exception(ev)) return;
        }
}

/**
 *
 */
static
void
client_run (Calculator         service,
	    CORBA_Environment *ev)
{
	CORBA_double      result=0.0;

	/*
         * use calculator service
         */
	
         <command>result = Calculator_add(service, 1.0, 2.0, ev); </command>
        if (etk_raised_exception (ev)) return;
	
        /* prints results to console */
        g_print("Result: 1.0 + 2.0 = %2.0f\n", result);
}

/*
 * main 
 */
int
main(int argc, char* argv[])
         
{
        CORBA_char  filename[] = "calculator.ref";

	Calculator service = CORBA_OBJECT_NIL;

        CORBA_Environment ev[1];
        CORBA_exception_init(ev);

	 <command>client_init (&amp;argc, argv, &amp;global_orb, ev); </command>
	etk_abort_if_exception(ev, "init failed");

	g_print ("Reading service reference from file \"%s\"\n", filename);

	 <command>service = (Calculator) etk_import_object_from_file (global_orb,
							       filename,
							       ev); </command>
        etk_abort_if_exception(ev, "import service failed");

	 <command>client_run (service, ev); </command>
        etk_abort_if_exception(ev, "service not reachable");
 
	 <command>client_cleanup (global_orb, service, ev); </command>
        etk_abort_if_exception(ev, "cleanup failed");
 
        exit (0);
}</programlisting>
</example>
</para>
<para>
Rather simple, but full of unexplained stuff.
Let's take a close look to the defined variables.

        <variablelist>
	  <varlistentry>
	    <term><parameter>
                env </parameter></term>
	    <listitem>
	      <para>
	      This varaible is used to hold information about
	      exceptions which might have occurred during a function
	      call. How to use this variable to detect errors in
	      function will be explained in a later example.
	      </para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><parameter>
             orb
            </parameter></term>
	    <listitem>
	      <para>
This is the ORB itself.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><parameter>
              server
            </parameter></term>
	    <listitem>
	      <para>
	      This is the object reference to the server.
	      </para>
	    </listitem>
	    </varlistentry>
	</variablelist>
</para>
<para>
The example above is a full functional client. 
The magic in this
example is the usage of the function
<emphasis>CORBA_ORB_string_to_object</emphasis> with the parameter
<parameter>argv[1]</parameter>. The explantion is that the program is
supposed to be called with the string representation of the Calculator 
server as the first parameter. How to obtain this string, will be
shown in the next example, where I describe how the server.
</para>
    </sect2>
    <sect2 id="calculator-server">
      <title>Calculator server</title>
      <para>
To implement the server, the IDL compiler does a great deal of work
for you. It can emit all the stuff necessary to set up the data
structures and function calls for the server implementation. All you
have to write is the setup stuff in your main function and the actual
implementation of the server functions. First I'll present the
functions and data structures the IDL compiler generates and then I'll 
show what's necessary to set up the environment for these functions to
work properly.
</para>
      <sect3 id="calculator-server-idl">
	<title>Calculator Implementation Skeleton</title>
	<para>
To ease the task of implementing the calculator the ORBit IDL compiler
can output an implementation skeleton of the server. 
This is enabled with the --skeleton-impl switch to the IDL compiler. 
The output of <command>orbit-idl-2 --skeleton-impl calculator.idl</command> looks like this (the default name for the generated source file is <filename>calculator-skelimpl.c</filename>:

<example>
	  <title>calculator-skelimpl.c</title>
	  <programlisting role="C">#include "calculator.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Calculator servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */
   /* ------ ---------- end ------------ ------ */
}
impl_POA_Calculator;

/*** Implementation stub prototypes ***/

static void impl_Calculator__fini(impl_POA_Calculator * servant,
				  CORBA_Environment * ev);
static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, 
		    CORBA_Environment * ev);

static CORBA_double
impl_Calculator_sub(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, 
		    CORBA_Environment * ev);

/*** epv structures ***/

static PortableServer_ServantBase__epv impl_Calculator_base_epv = {
   NULL,			/* _private data */
   (gpointer) &amp; impl_Calculator__fini,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Calculator__epv impl_Calculator_epv = {
   NULL,			/* _private */
   (gpointer) &amp; impl_Calculator_add,

   (gpointer) &amp; impl_Calculator_sub,

};

/*** vepv structures ***/

static POA_Calculator__vepv impl_Calculator_vepv = {
   &amp;impl_Calculator_base_epv,
   &amp;impl_Calculator_epv,
};

/*** Stub implementations ***/

static Calculator
impl_Calculator__create(PortableServer_POA poa, 
                        CORBA_Environment * ev)
{
   Calculator retval;
   impl_POA_Calculator *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Calculator, 1);
   newservant->servant.vepv = &amp;impl_Calculator_vepv;
   newservant->poa = poa;
   POA_Calculator__init((PortableServer_Servant) newservant, ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

static void
impl_Calculator__fini (impl_POA_Calculator * servant,
		       CORBA_Environment * ev)
{
   CORBA_Object_release((CORBA_Object) servant->poa, ev);
 
   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   POA_Calculator__fini((PortableServer_Servant) servant, ev);

   g_free (servant);
}

static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, 
		    CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   <command>retval = number1 + number2;</command>
   /* ------ ---------- end ------------ ------ */

   return retval;
}

static CORBA_double
impl_Calculator_sub(impl_POA_Calculator * servant,
                    const CORBA_double number1,
                    const CORBA_double number2, 
		    CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   <command>retval = number1 - number2;</command>
   /* ------ ---------- end ------------ ------ */

   return retval;
}</programlisting>
</example>
</para>
<para>
This source file provides you with most of the magic of a server. 
Note that we generate this file (with the <command>--skeleton-impl</command> switch) only once, 
and then the makefile invokes <command>orbit-idl-2</command> with no switch.
If you call <command>orbit-idl-2 --skeleton-impl</command> from the makefile, the previous file will be overwritten and your implementation code lost.
Once the implementation code is written, just include the source file at the
beginning of the
<filename>calculator-server.c</filename> file. 
</para>
<para>
For
this first example, I won't explain all the bits and pieces of the
generated source file. This will be done later. We'll just concentrate on 
getting the server running.
</para>
<para>
As you see there are two functions:
<funcsynopsis>
<funcprototype>
  <funcdef>CORBA_double <function>impl_Calculator_add</function></funcdef>
<paramdef>impl_POA_Calculator* <parameter>servant</parameter></paramdef>
<paramdef>CORBA_double <parameter>number1</parameter></paramdef>
<paramdef>CORBA_double <parameter>number2</parameter></paramdef>
<paramdef>CORBA_Environment* <parameter>ev</parameter></paramdef>
</funcprototype>
</funcsynopsis>
and
<funcsynopsis>
<funcprototype>
<funcdef>CORBA_double <function>impl_Calculator_sub</function></funcdef>
<paramdef>impl_POA_Calculator* <parameter>servant</parameter></paramdef>
<paramdef>CORBA_double <parameter>number1</parameter></paramdef>
<paramdef>CORBA_double <parameter>number2</parameter></paramdef>
<paramdef>CORBA_Environment* <parameter>ev</parameter></paramdef>
</funcprototype>
</funcsynopsis>

These two functions are implementing the function defined in the IDL
file. Because the IDL compiler doesn't provide you with a real
implementation (it doesn't know what the function should do), you have 
to extend this skeleton yourself where marked.
</para>
<para>
The <function>impl_Calculator_add()</function> should add it's two 
parameters and return the result so this function should be changed
into:

<example>
<title>calculator-skelimpl.c fragment</title>
<programlisting role="C">
static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
                    const CORBA_double number1,
                    const CORBA_double number2, 
		    CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   <command>retval = number1 + number2;</command>
   /* ------ ---------- end ------------ ------ */

   return retval;
}</programlisting>
</example>
</para>
</sect3>
      <sect3 id="calculator-server-main">
	<title>Calculator Server Implementation</title>

	<para>
The things you need in your minimal main function to make things work
can be implemented in the following way, note analogy to
<filename>echo-server.c</filename> of previous example.

          <example>
	    <title>calculator-server.c</title>
<programlisting role="C">/*
 * calculator-server program. Hacked from Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "calculator.h"
#include "calculator-skelimpl.c"

#include "examples-toolkit.h"

static CORBA_ORB          global_orb = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA root_poa   = CORBA_OBJECT_NIL; /* root POA
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command> CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGINT,  server_shutdown);
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

         <command>(*poa) = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;

         <command>poa_manager = PortableServer_POA__get_the_POAManager(*poa, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

	 <command>PortableServer_POAManager_activate(poa_manager, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

         <command>CORBA_Object_release ((CORBA_Object) poa_manager, ev); </command>
	return;

 failed_activation:
 failed_poamanager:
        CORBA_Object_release ((CORBA_Object) poa_manager, local_ev);
 failed_poa:
	CORBA_ORB_destroy(*orb, local_ev);		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
         <command>CORBA_ORB_run(orb, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	 <command>objid = PortableServer_POA_reference_to_id (poa, ref, ev); </command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	 <command>PortableServer_POA_deactivate_object (poa, objid, ev); </command>
	if (etk_raised_exception(ev)) return;

	 <command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev); </command>
	if (etk_raised_exception(ev)) return;

	CORBA_free (objid);

         <command>CORBA_Object_release ((CORBA_Object) poa, ev); </command>
	if (etk_raised_exception(ev)) return;
	
         <command>CORBA_Object_release (ref, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Calculator  ref = CORBA_OBJECT_NIL; 

	 <command>ref = impl_Calculator__create (poa, ev); </command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	CORBA_Object servant = CORBA_OBJECT_NIL;
	
	CORBA_char filename[] = "calculator.ref";

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	 <command>server_init (&amp;argc, argv, &amp;global_orb, &amp;root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed ORB init");

	 <command>servant = server_activate_service (global_orb, root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Writing service reference to: %s\n\n", filename);

	 <command>etk_export_object_to_file (global_orb, 
				   servant, 
				   filename, 
				   ev); </command>
	etk_abort_if_exception(ev, "failed exporting IOR");
	
	 <command>server_run (global_orb, ev); </command>
	etk_abort_if_exception(ev, "failed entering main loop");

	 <command>server_cleanup (global_orb, root_poa, servant, ev); </command>
	etk_abort_if_exception(ev, "failed cleanup");

	exit (0); }</programlisting> </example> </para> <para> I'm not
going to explain every line of this example yet; you only need to know
that it creates a servant object whos object-reference is written to
file "calculator.ref". File-IO is done using specific function
from "example-toolkit" laying beside each example; the file contains
a string always starting with the magic sequence "IOR:" and is read by
client application to get hold of servants object-reference. The IOR
string contains sufficient information to get to know host, port and
object key within server. ORBit2 provides tools to decode the IOR
string, namely <command>ior-decode-2</command>.  </para> </sect3> </sect2>

<sect2 id="calculator-compilation"> <title>Compiling server &amp; client</title> <para> The following
makefile can be used to compile both, the client and the server. Be
aware of the location of ORBit : on my system it has been installed
under /usr but it could be /usr/local if you have built it from the
sources, and hence the path for ORBIT variables below may
vary. If using ORBit binary packages shipped with Linux or BSD/Unix the simple makefile below will do.
<example> 
<title>makefile</title>
<programlisting role="make">PREFIX ?= /usr
CC = gcc
TARGETS=calculator-client calculator-server
ORBIT_IDL=orbit-idl-2
CFLAGS=-DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
       -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
       -I$(PREFIX)/lib/glib-2.0/include
LDFLAGS= -Wl,--export-dynamic -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm
IDLOUT=calculator-common.c calculator-stubs.c calculator-skels.c calculator.h
 
all: $(IDLOUT) calculator-client calculator-server
 
calculator-server.o : calculator-server.c calculator-skelimpl.c

calculator-client : calculator-client.o calculator-common.o calculator-stubs.o
calculator-server : calculator-server.o calculator-common.o calculator-skels.o
 
$(IDLOUT): calculator.idl
        $(ORBIT_IDL) calculator.idl
 
clean:
        rm -rf *.o *~ $(IDLOUT)
 
distclean: clean
        rm -rf calculator-client calculator-server</programlisting>
</example> 
</para>

<para>
After calling <command>make</command> in terminal window
all sources have been compiled and you should open a second terminal
window. In the first window we will start the server with the command:
<command>calculator-server &gt; calculator.ref</command>. The server
should print a very long string into the file
<filename>calculator.ref</filename>, starting with the 4 character
sequence <computeroutput>IOR:</computeroutput> In the second window we
start the client with the command <command>calculator-client `cat
calculator.ref` IOR-string</command>. You should not try to type the
IOR string, instead use the cut and paste functionality of your xterm
or whatever you are using.</para>
<para>
If everything works, you should get the following output:
<computeroutput>Result: 1.0 + 2.0 = 3</computeroutput>.
</para>
</sect2>
</sect1>


<!--
/******************************************************************/
/* Added by S. Genaud, Oct 28, 1999                               */
/******************************************************************/
-->
<sect1>
<title>
Account client &amp; server
</title>

<para>
In this third simple example, we will see how we can set up a 
client that can modify the value of a variable stored on the server. 
It is basically the way an account manager works. 
The stored variable here is balance. 
The idl definition (<filename>account.idl</filename>) for our account is : 
<example>
      <title>account.idl</title>

<programlisting role="account-idl">
   interface Account {
      void deposit (in unsigned long amount);
      void withdraw (in unsigned long amount);
      readonly attribute long balance;
   };</programlisting>
</example>

Then you have to generate the skeleton and stub files. In addition to
these two files the ORBit IDL compiler also generates a common file
and a header file. The common file implements the memory management
functions and other things, useful in the client as well as in the
server. The sequence to generate the C source files is rather
simple.
<computeroutput>$ <command>orbit-idl-2 --skeleton-impl
account.idl</command>
</computeroutput>
geenrates all the files we will use in this example.

<informaltable>
<tgroup cols="3">
<colspec align="left"/>
<colspec align="center"/>
<colspec align="center"/>
<thead>
<row>
<entry>File</entry><entry>Usage for Client</entry><entry>Usage for Server</entry>
</row>
</thead>
<tbody>
<row>
<entry>account.h</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>account-common.c</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>account-stubs.c</entry><entry>readonly</entry><entry>-</entry>
</row>

<row>
<entry>account-skels.c</entry><entry>-</entry><entry>readonly</entry>
</row>
<row><entry>account-skelimpl.c</entry><entry>-</entry><entry>template for user code</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Files remaining to write are listed in following table, starting with 
<emphasis>account-client.c</emphasis> in following chapter.
<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>account-client.c</entry><entry>write the client code</entry>
</row>
<row>
<entry>account-server.c</entry><entry>write the generic code for servant creation</entry>
</row>
</tbody></tgroup>
</informaltable>
</para>
<!--
******************************** Account client  ******************************************
-->
<sect2>
<title> Account client </title>
<para>
There is no difficulty in setting the client (at least no more than in the previous examples).
Only one thing has been added : we test for the availabilty of the server 
(<function>if (!acc_client) </function> ...) 
before invoking calls to the server.
</para>

<para>
<example>
      <title>account-client.c</title>
      
<programlisting role="account-client">/* account-client.c hacked by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.  */

#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "account.h"

#include "examples-toolkit.h" /* ie. etk_abort_if_exception() */ 

static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
 
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
client_shutdown (int sig)
{
        CORBA_Environment  local_ev[1];
        CORBA_exception_init(local_ev);
 
        if (global_orb != CORBA_OBJECT_NIL)
        {
                 <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}
 
        
/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_client_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */
static
void
client_init (int               *argc_ptr,
	     char              *argv[],
             CORBA_ORB         *orb,
             CORBA_Environment *ev)
{
        /* init signal handling */
 
        signal(SIGINT,  client_shutdown);
        signal(SIGTERM, client_shutdown);
         
        /* create Object Request Broker (ORB) */
         
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
        if (etk_raised_exception(ev)) return;
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static
void
client_cleanup (CORBA_ORB                 orb,
                CORBA_Object              service,
                CORBA_Environment        *ev)
{
        /* releasing managed object */
         <command>CORBA_Object_release(service, ev); </command>
        if (etk_raised_exception(ev)) return;
 
        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
                if (etk_raised_exception(ev)) return;
        }
}

/**
 *
 */
static
void
client_run (Account            service,
	    CORBA_long         amount,
	    CORBA_Environment *ev)
{
	CORBA_long balance=0;

	/*
         * use calculator server
         */
         
         <command>balance = Account__get_balance (service, ev); </command>
	if (etk_raised_exception (ev)) return;
         
        g_print ("balance %5d, ", balance);
         
        if (amount > 0)
        {
                 <command>Account_deposit (service, amount, ev); </command>
                if (etk_raised_exception (ev)) return;
        }
        else
        {
                 <command>Account_withdraw (service, abs(amount), ev); </command>
                if (etk_raised_exception (ev)) return;
        }
                                                                               
         <command>balance = Account__get_balance (service, ev); </command>
	if (etk_raised_exception (ev)) return;
                                                                               
        g_print ("new balance %5d\n", balance);
}

/*
 * main 
 */
int
main(int argc, char* argv[])
         
{
        CORBA_char        filename[] = "account.ref";
        CORBA_long        amount=0;

	Account service = CORBA_OBJECT_NIL;

        CORBA_Environment ev[1];
        CORBA_exception_init(ev);

	 <command>client_init (&amp;argc, argv, &amp;global_orb, ev); </command>
	etk_abort_if_exception(ev, "init failed");

        if (argc<2) g_error ("usage: %s &lt;amount&gt;", argv[0]);

        amount  = atoi(argv[1]);

	g_print ("Reading service reference from file \"%s\"\n", filename);

	 <command>service = (Account) etk_import_object_from_file (global_orb,
							 filename,
							 ev); </command>
        etk_abort_if_exception(ev, "import service failed");

	 <command>client_run (service, amount, ev); </command>
        etk_abort_if_exception(ev, "service not reachable");
 
	 <command>client_cleanup (global_orb, service, ev); </command>
        etk_abort_if_exception(ev, "cleanup failed");
 
        exit (0);
}


</programlisting>
</example>
</para>
</sect2>

<!--
******************************* Account server  *****************************************
-->
<sect2>
<title>Account server</title>

<sect3>
<title>Account server Skeleton Implementation</title>
<para>

For the server, like in the previous example, we first generate the source file
<filename>account-skelimpl.c</filename> 
that will receive the implementation code for
the methods.
This is done once again with <userinput>orbit-idl-2 --skeleton-impl
account.idl</userinput>.
</para>

<para>
Now, let us edit <filename>account-skelimpl.c</filename>. 
We search for the the <varname>balance</varname> attribute that was declared
in the IDL file. 
At the beginning of the file, we can spot the way it has been translated into
C by the idl compiler:

<example>
<title>
account-skelimpl.c fragment - object declaration
</title>
<programlisting>typedef struct
{
   POA_Account servant;
   PortableServer_POA poa;

   CORBA_long attr_balance;

   /* ------ add private attributes here ------ */
   <command>CORBA_long attr_balance;</command>
   /* ------ ---------- end ------------ ------ */
}
impl_POA_Account;</programlisting>
</example>
So, the server methods (withdraw and deposit) will have to manage the balance
of the account through the <varname>servant->attr_balance</varname> (the
servant variable is passed as parameter to each method).
</para>


<para>
Now, let us get to the end of the file and find the methods stubs.
We find the <function>impl_Account_*</function> functions, to which we add the
implementation code. 
This could be:
</para>

<!--
*************************** Account Skeleton Implementation ******************************
-->

<example>
<title>
account-skelimpl.c fragment - method definition
</title>
<programlisting>static void
impl_Account_deposit(impl_POA_Account * servant,
		     const CORBA_unsigned_long amount, CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   <command>servant->attr_balance += amount;</command>
   /* ------ ---------- end ------------ ------ */
}

static void
impl_Account_withdraw(impl_POA_Account * servant,
		      const CORBA_unsigned_long amount,
		      CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   <command>servant->attr_balance -= amount;</command>
   /* ------ ---------- end ------------ ------ */
}

static CORBA_long
impl_Account__get_balance(impl_POA_Account * servant, CORBA_Environment * ev)
{
   CORBA_long retval;

   /* ------   insert method code here   ------ */
   <command>retval = servant->attr_balance;</command>
   /* ------ ---------- end ------------ ------ */

   return retval;
}</programlisting>
</example>

<para>The missing key stone is the constructor that establishs
initial, consistent state for object on creation.</para>

<example>
<title>
account-skelimpl.c fragment - constructor
</title>
<programlisting>...
static Account
impl_Account__create(PortableServer_POA poa, CORBA_Environment * ev)
{
   Account retval;
   impl_POA_Account *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Account, 1);
   newservant->servant.vepv = &amp;impl_Account_vepv;
   newservant->poa =       
      (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object) poa, ev);
   POA_Account__init((PortableServer_Servant) newservant, ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   <command>newservant->attr_balance = 0;</command>
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}
..</programlisting>
</example>
<!--
**************************** Server generic code *********************************
-->
</sect3>

<sect3>
<title>Account server implementation</title>

<para>
Lastly, we have to write a rather generic code to set up the server.
We call it <filename>account-server.c</filename>.
It is roughly the same code as in the calculator and echo examples.
The code just initializes the ORB and publishes an IOR for the server object.
</para>

<example>
<title>
account-server.c 
</title>
<programlisting>/*
 * account-server program. Hacked from Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "account.h"
#include "account-skelimpl.c"

#include "examples-toolkit.h" /* provides etk_abort_if_exception */ 

static CORBA_ORB          global_orb = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA root_poa   = CORBA_OBJECT_NIL; /* root POA
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                 <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGINT,  server_shutdown);
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

         <command>(*poa) = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;

         <command>poa_manager = PortableServer_POA__get_the_POAManager(*poa, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

	 <command>PortableServer_POAManager_activate(poa_manager, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

         <command>CORBA_Object_release ((CORBA_Object) poa_manager, ev); </command>
	return;

 failed_activation:
 failed_poamanager:
        CORBA_Object_release ((CORBA_Object) poa_manager, local_ev);
 failed_poa:
	CORBA_ORB_destroy(*orb, local_ev);		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
         <command>CORBA_ORB_run(orb, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	 <command>objid = PortableServer_POA_reference_to_id (poa, ref, ev); </command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	 <command>PortableServer_POA_deactivate_object (poa, objid, ev); </command>
	if (etk_raised_exception(ev)) return;

	 <command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev); </command>
	if (etk_raised_exception(ev)) return;

	CORBA_free (objid);

         <command>CORBA_Object_release ((CORBA_Object) poa, ev); </command>
	if (etk_raised_exception(ev)) return;
	
         <command>CORBA_Object_release (ref, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Account ref = CORBA_OBJECT_NIL; 

	 <command>ref = impl_Account__create (poa, ev); </command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	CORBA_Object servant = CORBA_OBJECT_NIL;
	
	CORBA_char filename[] = "account.ref";

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	 <command>server_init (&amp;argc, argv, &amp;global_orb, &amp;root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed ORB init");

	 <command>servant = server_activate_service (global_orb, root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Writing service reference to: %s\n\n", filename);

	 <command>etk_export_object_to_file (global_orb, 
				   servant, 
				   filename, 
				   ev); </command>
	etk_abort_if_exception(ev, "failed exporting IOR");
	
	 <command>server_run (global_orb, ev); </command>
	etk_abort_if_exception(ev, "failed entering main loop");

	 <command>server_cleanup (global_orb, root_poa, servant, ev); </command>
	etk_abort_if_exception(ev, "failed cleanup");

	exit (0);
}
	


</programlisting>
</example>

</sect3>
</sect2>

<!--
************************** Makefile *************************
-->

<sect2>
<title>
Compiling server &amp; client
</title>
<para>
The Makefile is the roughly the same as the one in the Calculator
example. By now the schema should be clear and you should be able to
reuse this Makefile for numerous small projects.
<example>
<title>Makefile for the Account example</title>

<programlisting>PREFIX ?= /usr
CC = gcc
TARGETS=account-client account-server
ORBIT_IDL=orbit-idl-2
CFLAGS=-DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
       -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
       -I$(PREFIX)/lib/glib-2.0/include
LDFLAGS= -Wl,--export-dynamic -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm
IDLOUT=account-common.c account-stubs.c account-skels.c account.h
 
all: $(IDLOUT) account-client account-server
 
account-server.o : account-server.c account-skelimpl.c

account-client : account-client.o account-common.o account-stubs.o
account-server : account-server.o account-common.o account-skels.o
 
$(IDLOUT): account.idl
        $(ORBIT_IDL) account.idl
 
clean:
        rm -rf *.o *~ $(IDLOUT)
 
distclean: clean
        rm -rf account-client account-server</programlisting>
</example>
</para>
</sect2>

</sect1>


<sect1 id="byteseq">
<title>Byte-Sequence client &amp; server</title>
      <para>
      In this more advanced example, we will see how we can set up a
      client exchanging byte sequences with server.  The idl
      definition (<filename>byteseq.idl</filename>) covers in-, out-
      and inout-parameters and looks like:
      <example>
	  <title>byteseq.idl</title>

	  <programlisting role="byteseq-idl">module Examples {
         
        module ByteSeq {
                typedef sequence&lt;octet&gt; Chunk;
                 
                interface Storage {
                        void  set (in Chunk chunk);
                        Chunk get ();
                };
        };
};</programlisting>
	</example>

     Then you have to generate the skeleton and stub files. In
     addition to these two files the ORBit IDL compiler also generates
     a common file and a header file. The common file implements the
     memory management functions and other things, useful in the
     client as well as in the server. The sequence to generate the C
     source files is rather simple.  
     <computeroutput>$<command>orbit-idl-2 --skeleton-impl byteseq.idl</command></computeroutput> geenrates all the files we will use in this example.

     <informaltable>
	  <tgroup cols="3">
	    <colspec align="left"/>
	    <colspec align="center"/>
	    <colspec align="center"/>
	    <thead>
	      <row>
		<entry>File</entry><entry>Usage for Client</entry><entry>Usage for Server</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>byteseq.h</entry><entry>readonly</entry><entry>readonly</entry>
	      </row>
	      <row>
		<entry>byteseq-common.c</entry><entry>readonly</entry><entry>readonly</entry>
	      </row>
	      <row>
		<entry>byteseq-stubs.c</entry><entry>readonly</entry><entry>-</entry>
	      </row>
	      
	      <row>
		<entry>byteseq-skels.c</entry><entry>-</entry><entry>readonly</entry>
	      </row>
	      <row><entry>byteseq-skelimpl.c</entry><entry>-</entry><entry>template for user code</entry>
	      </row>
	    </tbody>
	  </tgroup>
     </informaltable>

     Files remaining to write are listed in following table, starting with 
     <emphasis>byteseq-client.c</emphasis> in following chapter.
     <informaltable>
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry>byteseq-client.c</entry><entry>write the client code</entry>
	      </row>
	      <row>
		<entry>byteseq-server.c</entry><entry>write the generic code for servant creation</entry>
	      </row>
	    </tbody></tgroup>
	</informaltable>
   </para>
   <sect2><title>Byte-Sequence client</title>
	<para>
<example>
<title>byteseq-client.c</title>
<programlisting role="C">/* byteseq-client.c hacked by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.  */

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "byteseq.h"

#include "examples-toolkit.h" /* ie. etk_etk_abort_if_exception() */
 
static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
 
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
client_shutdown (int sig)
{
        CORBA_Environment  local_ev[1];
        CORBA_exception_init(local_ev);
 
        if (global_orb != CORBA_OBJECT_NIL)
        {
                 <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}
 
        
/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_client_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */
static
void
client_init (int               *argc_ptr,
	     char              *argv[],
             CORBA_ORB         *orb,
             CORBA_Environment *ev)
{
        /* init signal handling */
 
        signal(SIGINT,  client_shutdown);
        signal(SIGTERM, client_shutdown);
         
        /* create Object Request Broker (ORB) */
         
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
        if (etk_raised_exception(ev)) return;
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static
void
client_cleanup (CORBA_ORB                 orb,
                Examples_ByteSeq_Storage  servant,
                CORBA_Environment        *ev)
{
        /* releasing managed object */
         <command>CORBA_Object_release(servant, ev); </command>
        if (etk_raised_exception(ev)) return;
 
        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
                if (etk_raised_exception(ev)) return;
        }
}

/**
 *
 */
static
void
client_run_set (Examples_ByteSeq_Storage  servant,
		CORBA_Environment        *ev)
{

	CORBA_long LEN      = 4*1024; /* 4KB */ 
	CORBA_long ITER     = 10; 

	CORBA_long iter     = 0; 

	Examples_ByteSeq_Chunk* chunk = NULL;


	/* flood service witth large chunks of byte streams */
	for (iter = 0; iter &lt; ITER; ++iter)
	{
		CORBA_long len      = 0; 
		CORBA_octet elem    = 'A';

		g_print ("+");

	 <command>	chunk = ORBit_sequence_alloc (TC_CORBA_sequence_CORBA_octet,0); </command>

		for (len = 0; len &lt; LEN; ++len)
		 <command>	ORBit_sequence_append (chunk, &amp;elem); </command>

		 <command>Examples_ByteSeq_Storage_set (servant, chunk, ev);  </command>
		if (etk_raised_exception(ev)) return;

		CORBA_free (chunk);
	}
}

/**
 *
 */
static
void
client_run_get (Examples_ByteSeq_Storage  servant,
		CORBA_Environment        *ev)
{
	CORBA_long n=10;
	CORBA_long i=0;

	Examples_ByteSeq_Chunk* chunk = NULL; 

	/* increment sequence length, beginning with 0 up to 2048 */
	for (i=0; i&lt;n; ++i)
	{
		g_print ("-");

		 <command>chunk = Examples_ByteSeq_Storage_get (servant, ev);  </command>
		if (etk_raised_exception(ev)) return;

 		CORBA_free (chunk);
	}
}

/*
 * main 
 */
int
main(int argc, char* argv[])
{
	CORBA_char *filename = "byteseq.ref";

        Examples_ByteSeq_Storage  servant = CORBA_OBJECT_NIL;

        CORBA_Environment ev[1];
        CORBA_exception_init(ev);

	 <command>client_init (&amp;argc, argv, &amp;global_orb, ev); </command>
	etk_abort_if_exception(ev, "init failed");

	g_print ("Reading service reference from file \"%s\"\n", filename);

	 <command>servant = (Examples_ByteSeq_Storage) 
		etk_import_object_from_file (global_orb,
					     filename,
					     ev); </command>
        etk_abort_if_exception(ev, "exporting IOR failed");

	 <command>client_run_set (servant, ev); </command>
        etk_abort_if_exception(ev, "client stopped");
 
	 <command>client_run_get (servant, ev); </command>
        etk_abort_if_exception(ev, "client stopped");
 
	 <command>client_cleanup (global_orb, servant, ev); </command>
        etk_abort_if_exception(ev, "cleanup failed");
 
        exit (0);
}</programlisting>
</example>
        </para>
      </sect2>

      <sect2>
	<title>Byte-Sequence server</title>
	<para>
<example>
<title>byteseq-server.c</title>
<programlisting role="C">/*
 * byteseq-server program. Hacked from Examples test suite 
 * by Frank Rehberger &lt;F.Rehberger@xtradyne.de&gt;
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "byteseq.h"
#include "byteseq-skelimpl.c" 

#include "examples-toolkit.h" /* provides etk_abort_if_exception() */

static CORBA_ORB          global_orb = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA root_poa   = CORBA_OBJECT_NIL; /* root POA
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                 <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGINT,  server_shutdown);
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

         <command>(*poa) = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;

         <command>poa_manager = PortableServer_POA__get_the_POAManager(*poa, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

	 <command>PortableServer_POAManager_activate(poa_manager, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

         <command>CORBA_Object_release ((CORBA_Object) poa_manager, ev); </command>
	return;

 failed_activation:
 failed_poamanager:
        CORBA_Object_release ((CORBA_Object) poa_manager, local_ev);
 failed_poa:
	CORBA_ORB_destroy(*orb, local_ev);		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
         <command>CORBA_ORB_run(orb, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	 <command>objid = PortableServer_POA_reference_to_id (poa, ref, ev); </command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	 <command>PortableServer_POA_deactivate_object (poa, objid, ev); </command>
	if (etk_raised_exception(ev)) return;

	 <command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev); </command>
	if (etk_raised_exception(ev)) return;

	CORBA_free (objid);

         <command>CORBA_Object_release ((CORBA_Object) poa, ev); </command>
	if (etk_raised_exception(ev)) return;
	
         <command>CORBA_Object_release (ref, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Examples_ByteSeq_Storage ref = CORBA_OBJECT_NIL;

	 <command>ref = impl_Examples_ByteSeq_Storage__create (poa, ev); </command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	CORBA_Object servant = CORBA_OBJECT_NIL;
	
	CORBA_char filename[] = "byteseq.ref";

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	 <command>server_init (&amp;argc, argv, &amp;global_orb, &amp;root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed ORB init");

	 <command>servant = server_activate_service (global_orb, root_poa, ev); </command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Writing service reference to: %s\n\n", filename);

	 <command>etk_export_object_to_file (global_orb, 
				   servant, 
				   filename, 
				   ev); </command>
	etk_abort_if_exception(ev, "failed exporting IOR");
	
	 <command>server_run (global_orb, ev); </command>
	etk_abort_if_exception(ev, "failed entering main loop");

	 <command>server_cleanup (global_orb, root_poa, servant, ev); </command>
	etk_abort_if_exception(ev, "failed cleanup");

	exit (0);
}</programlisting>
</example>

<example>
<title>byteseq-skelimpl.c</title>
<programlisting>/* This is a template file generated by command */
/* orbit-idl-2 --skeleton-impl byteseq.idl */
/* User must edit this file, inserting servant  */
/* specific code between markers. */

#include "byteseq.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Examples_ByteSeq_Storage servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */  
    <command>Examples_ByteSeq_Chunk * chunk; </command>
   /* ------ ---------- end ------------ ------ */
} impl_POA_Examples_ByteSeq_Storage;

/*** Implementation stub prototypes ***/

static void
impl_Examples_ByteSeq_Storage__fini(impl_POA_Examples_ByteSeq_Storage *
				    servant, CORBA_Environment * ev);
static void
impl_Examples_ByteSeq_Storage_set(impl_POA_Examples_ByteSeq_Storage * servant,
				  const Examples_ByteSeq_Chunk * chunk,
				  CORBA_Environment * ev);

static Examples_ByteSeq_Chunk
   *impl_Examples_ByteSeq_Storage_get(impl_POA_Examples_ByteSeq_Storage *
				      servant, CORBA_Environment * ev);


/*** epv structures ***/

static PortableServer_ServantBase__epv impl_Examples_ByteSeq_Storage_base_epv
   = {
   NULL,			/* _private data */
   (gpointer) &amp; impl_Examples_ByteSeq_Storage__fini,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Examples_ByteSeq_Storage__epv impl_Examples_ByteSeq_Storage_epv = {
   NULL,			/* _private */
   (gpointer) &amp; impl_Examples_ByteSeq_Storage_set,

   (gpointer) &amp; impl_Examples_ByteSeq_Storage_get
};

/*** vepv structures ***/

static POA_Examples_ByteSeq_Storage__vepv impl_Examples_ByteSeq_Storage_vepv = {
   &amp;impl_Examples_ByteSeq_Storage_base_epv,
   &amp;impl_Examples_ByteSeq_Storage_epv,
};

/*** Stub implementations ***/

static Examples_ByteSeq_Storage
impl_Examples_ByteSeq_Storage__create(PortableServer_POA poa,
				      CORBA_Environment * ev)
{
   Examples_ByteSeq_Storage retval;
   impl_POA_Examples_ByteSeq_Storage *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Examples_ByteSeq_Storage, 1);
   newservant-&gt;servant.vepv = &amp;impl_Examples_ByteSeq_Storage_vepv;
   newservant-&gt;poa =
      (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object) poa, ev);

   POA_Examples_ByteSeq_Storage__init((PortableServer_Servant) newservant,
				      ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
    <command>newservant-&gt;chunk = ORBit_sequence_alloc (TC_CORBA_sequence_CORBA_octet, 64); </command>   
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

/**
 * impl_Examples_ByteSeq_Storage__fini
 * 
 * Destructor called after servant has been deactivated finally.
 * In case any operation is invoked, application is being delayed.
**/
static void
impl_Examples_ByteSeq_Storage__fini(impl_POA_Examples_ByteSeq_Storage *
				    servant, CORBA_Environment * ev)
{
   CORBA_Object_release((CORBA_Object) servant-&gt;poa, ev);

   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */
    <command>CORBA_free (servant-&gt;chunk); </command>
   /* ------ ---------- end ------------- ------ */

   POA_Examples_ByteSeq_Storage__fini((PortableServer_Servant) servant, ev);

   g_free(servant);
}

static void
impl_Examples_ByteSeq_Storage_set(impl_POA_Examples_ByteSeq_Storage * servant,
				  const Examples_ByteSeq_Chunk * chunk,
				  CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
    <command>ORBit_sequence_set_size (servant-&gt;chunk, chunk-&gt;_length);
    
   {
           CORBA_long i=0;
           for (i = 0; i &lt; chunk-&gt;_length; ++i)
                   ORBit_sequence_index (servant-&gt;chunk, i)
                           = ORBit_sequence_index (chunk, i);
   } </command>
   /* ------ ---------- end ------------ ------ */
}

static Examples_ByteSeq_Chunk *
impl_Examples_ByteSeq_Storage_get(impl_POA_Examples_ByteSeq_Storage * servant,
				  CORBA_Environment * ev)
{
   Examples_ByteSeq_Chunk *retval;

   /* ------   insert method code here   ------ */
    <command>retval = ORBit_sequence_alloc (TC_CORBA_sequence_CORBA_octet,
                                  servant-&gt;chunk-&gt;_length);

   {
           CORBA_long i=0;
           for (i = 0; i &lt; servant-&gt;chunk-&gt;_length; ++i)
                   ORBit_sequence_index (retval, i)
                           = ORBit_sequence_index (servant-&gt;chunk, i);
   } </command>
   /* ------ ---------- end ------------ ------ */

   return retval;
}</programlisting>
</example>

        </para>
      </sect2>

      <sect2>
	<title>Compiling client &amp; server</title>
	<para>
<example>
<title>Makefile</title>
<programlisting>PREFIX ?= /usr
CC = gcc
TARGETS=byteseq-client byteseq-server
ORBIT_IDL=$(PREFIX)/bin/orbit-idl-2
CFLAGS=-g -DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
         -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
         -I$(PREFIX)/lib/glib-2.0/include 
LDFLAGS= -Wl,--export-dynamic  -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm        \
             -lORBitCosNaming-2
IDLOUT=byteseq-common.c byteseq-stubs.c byteseq-skels.c byteseq.h

all: $(IDLOUT) byteseq-client byteseq-server

byteseq-server.o: byteseq-server.c byteseq-skelimpl.c
byteseq-client : byteseq-client.o byteseq-stubs.o byteseq-common.o examples-toolkit.o
byteseq-server : byteseq-server.o byteseq-skels.o byteseq-common.o examples-toolkit.o 

$(IDLOUT): byteseq.idl
	$(ORBIT_IDL) byteseq.idl

%-skelimpl.c: %.idl
	$(ORBIT_IDL) --skeleton-impl $^

clean:
	rm -rf *.o *~ $(IDLOUT) 

distclean: clean
	rm -rf byteseq-client byteseq-server</programlisting>
</example>
         </para>
      </sect2>
</sect1>

<sect1 id="badcall">
<title>BadCall client &amp; server</title>
      <para>
<example>
<title>badcall.idl</title>
<programlisting role="IDL">
module Examples {

	interface BadCall {
		struct Foo { 
			double fval; 
		};

		exception NoParam     { };
		exception SingleParam { string mesg; };
		exception DoubleParam { string mesg; long val; };

		Foo trigger (in long val, out Foo bar) 
			raises (NoParam, SingleParam, DoubleParam);
	};
};</programlisting>
</example>

<computeroutput>$ <command>orbit-idl-2 --skeleton-impl
badcall.idl</command>
</computeroutput>
geenrates all the files we will use in this example.

<informaltable>
<tgroup cols="3">
<colspec align="left"/>
<colspec align="center"/>
<colspec align="center"/>
<thead>
<row>
<entry>File</entry><entry>Usage for Client</entry><entry>Usage for Server</entry>
</row>
</thead>
<tbody>
<row>
<entry>badcall.h</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>badcall-common.c</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>badcall-stubs.c</entry><entry>readonly</entry><entry>-</entry>
</row>

<row>
<entry>badcall-skels.c</entry><entry>-</entry><entry>readonly</entry>
</row>
<row><entry>badcall-skelimpl.c</entry><entry>-</entry><entry>template for user code</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Files remaining to write are listed in following table, starting with 
<emphasis>badcall-client.c</emphasis> in following chapter.
<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>badcall-client.c</entry><entry>write the client code</entry>
</row>
<row>
<entry>badcall-server.c</entry><entry>write the generic code for servant creation</entry>
</row>
</tbody></tgroup>
</informaltable>

      </para>
      <sect2>
	<title>BadCall client</title>
	<para>
<example>
<title>badcall-client.c</title>
<programlisting role="C">/* badcall-client.c hacked by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.  */

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "badcall.h"

#include "examples-toolkit.h" /* ie. etk_abort_if_exception() */

static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
 
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
client_shutdown (int sig)
{
        CORBA_Environment  local_ev[1];
        CORBA_exception_init(local_ev);
 
        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}
 
        
/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_client_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */
static
void
client_init (int               *argc_ptr,
	     char              *argv[],
             CORBA_ORB         *orb,
             CORBA_Environment *ev)
{
        /* init signal handling */
 
        signal(SIGINT,  client_shutdown);
        signal(SIGTERM, client_shutdown);
         
        /* create Object Request Broker (ORB) */
         
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
        if (etk_raised_exception(ev)) return;
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static
void
client_cleanup (CORBA_ORB                 orb,
                CORBA_Object              servant,
                CORBA_Environment        *ev)
{
        /* releasing managed object */
         <command>CORBA_Object_release(servant, ev); </command>
        if (etk_raised_exception(ev)) return;
 
        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
                if (etk_raised_exception(ev)) return;
        }
}


static 
void
client_trigger_exception (Examples_BadCall          servant,
			  CORBA_long                arg,
			  CORBA_Environment        *ev)
{
	CORBA_long            in_arg  = arg;	
	Examples_BadCall_Foo *out_arg = NULL;

	Examples_BadCall_Foo  ret_val;
	
	 <command>ret_val = Examples_BadCall_trigger (servant, 
					    in_arg, 
					    out_arg,
					    ev);  </command>
	
	switch(etk_exception_type(ev)) {
	case CORBA_NO_EXCEPTION:/* successful outcome*/
		
		/* now use data the server delivered to client
		 * over the return-value, or those out- and
		 * inout-parameters */
		
		break;
		
	case CORBA_USER_EXCEPTION:/* a user-defined exception */
		if (etk_raised_exception_is_a (ev, 
					       ex_Examples_BadCall_NoParam)) 
		{
			/* NoParam exception  does not own members */ 
			Examples_BadCall_NoParam *bc 
				= (Examples_BadCall_NoParam*)CORBA_exception_value(ev);
			g_warning ("raised exception: %s\n",  
				   CORBA_exception_id(ev));
		} 
		else if (etk_raised_exception_is_a (ev,
						    ex_Examples_BadCall_SingleParam)) 
		{
			Examples_BadCall_SingleParam *bc 
				= (Examples_BadCall_SingleParam*)
				CORBA_exception_value(ev);
			
			g_warning ("raised exception: %s\n"
				   " mesg: %s\n",  
				   CORBA_exception_id(ev),
				   bc-&gt;mesg);

		} else if (etk_raised_exception_is_a 
			   (ev, ex_Examples_BadCall_DoubleParam)) 
		{
			Examples_BadCall_DoubleParam *bc 
				= (Examples_BadCall_DoubleParam*)
				CORBA_exception_value(ev);
			
			g_warning ("raised exception: %s\n"
				   " mesg: %s\n"
				   " val: %d\n",  
				   CORBA_exception_id(ev),
				   bc-&gt;mesg,
				   bc-&gt;val);
		}
		else 
		{       
			/* should never get here ... */
			g_print ("unexpected CORBA_USER_EXCEPTION -%s\n",
				 CORBA_exception_id(ev));
		}
		break;
		
	case CORBA_SYSTEM_EXCEPTION:
	default: /* standard exception */
		/*
		 * CORBA_exception_id() can be used to determine which
		 * particular standard exception was raised; the minor
		 * member of the struct associated with the exception
		 * (as yielded by CORBA_exception_value()) may provide
		 * additional system-specific information about the
		 * exception
		 */
		g_print ("BadCall::trigger raised system exception: %s\n",  
			 CORBA_exception_id(ev));
		
		break;
	}
	
	/* free any storage associated with exception */
	CORBA_exception_free(ev);
	
	CORBA_free (out_arg); /* free Foo data */
	
}

/**
 *
 */
static
void
client_run (Examples_BadCall          servant,
	    CORBA_Environment        *ev)
{
	CORBA_long N=1000;
	CORBA_long i=0;

	/* increment sequence length, beginning with 0 up to 2048 */
	for (i=0; i&lt;N; ++i)
	{
		 <command>client_trigger_exception (servant, i, ev); </command>
	}
}


/*
 * main 
 */
int
main(int argc, char* argv[])
{
	CORBA_char filename[] = "badcall.ref";

        Examples_BadCall  servant = CORBA_OBJECT_NIL;

        CORBA_Environment ev[1];
        CORBA_exception_init(ev);

	 <command>client_init (&amp;argc, argv, &amp;global_orb, ev); </command>
	etk_abort_if_exception(ev, "init failed");

	g_print ("Reading service reference from file \"%s\"\n", 
		 filename);

	 <command>servant = etk_import_object_from_file (global_orb,
					       filename,
					       ev); </command>
        etk_abort_if_exception(ev, "importing IOR failed");

	 <command>client_run (servant, ev); </command>
        etk_abort_if_exception(ev, "client stopped");
 
	 <command>client_cleanup (global_orb, servant, ev); </command>
        etk_abort_if_exception(ev, "cleanup failed");
 
        exit (0);
}</programlisting>
</example>
        </para>
      </sect2>
      <sect2>
	<title>BadCall server</title>
	<para>
<example>
<title>badcall-server.c</title>
<programlisting role="C">/*
 * echo-server program. Hacked from Echo test suite by by Frank
 * Rehberger &lt;F.Rehberger@xtradyne.de&gt;
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "badcall.h"
#include "badcall-skelimpl.c" 

#include "examples-toolkit.h" /* ie. etk_abort_if_exception() */

static CORBA_ORB          global_orb = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA root_poa   = CORBA_OBJECT_NIL; /* root POA
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                 <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev); </command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGINT,  server_shutdown);
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
         <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

         <command>(*poa) = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;

         <command>poa_manager = PortableServer_POA__get_the_POAManager(*poa, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

	 <command>PortableServer_POAManager_activate(poa_manager, ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

         <command>CORBA_Object_release ((CORBA_Object) poa_manager, ev); </command>
	return;

 failed_activation:
 failed_poamanager:
        CORBA_Object_release ((CORBA_Object) poa_manager, local_ev);
 failed_poa:
	CORBA_ORB_destroy(*orb, local_ev);		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
         <command>CORBA_ORB_run(orb, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	 <command>objid = PortableServer_POA_reference_to_id (poa, ref, ev); </command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	 <command>PortableServer_POA_deactivate_object (poa, objid, ev); </command>
	if (etk_raised_exception(ev)) return;

	 <command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev); </command>
	if (etk_raised_exception(ev)) return;

	CORBA_free (objid);

         <command>CORBA_Object_release ((CORBA_Object) poa, ev); </command>
	if (etk_raised_exception(ev)) return;
	
         <command>CORBA_Object_release (ref, ev); </command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                 <command>CORBA_ORB_destroy(orb, ev); </command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Examples_BadCall ref = CORBA_OBJECT_NIL; 

	<command>ref = impl_Examples_BadCall__create (poa, ev);</command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	CORBA_Object servant = CORBA_OBJECT_NIL;
	
	CORBA_char filename[] = "badcall.ref";

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	<command>server_init (&amp;argc, argv, &amp;global_orb, &amp;root_poa, ev);</command>
	etk_abort_if_exception(ev, "failed ORB init");

	<command>servant = server_activate_service (global_orb, root_poa, ev);</command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Writing service reference to: %s\n\n", filename);

	<command>etk_export_object_to_file (global_orb, 
				   servant, 
				   filename, 
				   ev);</command>
	etk_abort_if_exception(ev, "failed exporting IOR");
	
	<command>server_run (global_orb, ev);</command>
	etk_abort_if_exception(ev, "failed entering main loop");

	<command>server_cleanup (global_orb, root_poa, servant, ev);</command>
	etk_abort_if_exception(ev, "failed cleanup");

	exit (0);
}
</programlisting>
</example>
<example>
<title>badcall-skelimpl.c</title>
<programlisting role="C">/* This is a template file generated by command */
/* orbit-idl-2 --skeleton-impl badcall.idl */
/* User must edit this file, inserting servant  */
/* specific code between markers. */

#include "badcall.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Examples_BadCall servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */
   <command>CORBA_long counter;</command>
   /* ------ ---------- end ------------ ------ */
} impl_POA_Examples_BadCall;

/*** Implementation stub prototypes ***/

static void impl_Examples_BadCall__fini(impl_POA_Examples_BadCall *
					servant, CORBA_Environment * ev);

static Examples_BadCall_Foo
impl_Examples_BadCall_trigger(impl_POA_Examples_BadCall * servant,
			      const CORBA_long val,
			      Examples_BadCall_Foo * bar,
			      CORBA_Environment * ev);

/*** epv structures ***/

static PortableServer_ServantBase__epv impl_Examples_BadCall_base_epv = {
   NULL,			/* _private data */
   (gpointer) &amp; impl_Examples_BadCall__fini,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Examples_BadCall__epv impl_Examples_BadCall_epv = {
   NULL,			/* _private */

   (gpointer) &amp; impl_Examples_BadCall_trigger,

};

/*** vepv structures ***/

static POA_Examples_BadCall__vepv impl_Examples_BadCall_vepv = {
   &amp;impl_Examples_BadCall_base_epv,
   &amp;impl_Examples_BadCall_epv,
};

/*** Stub implementations ***/

static Examples_BadCall
impl_Examples_BadCall__create(PortableServer_POA poa, CORBA_Environment * ev)
{
   Examples_BadCall retval;
   impl_POA_Examples_BadCall *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Examples_BadCall, 1);
   newservant-&gt;servant.vepv = &amp;impl_Examples_BadCall_vepv;
   newservant-&gt;poa =
      (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object) poa, ev);
   POA_Examples_BadCall__init((PortableServer_Servant) newservant, ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */ 
   <command>newservant-&gt;counter=0;  /* init */</command>
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

static void
impl_Examples_BadCall__fini (impl_POA_Examples_BadCall * servant,
			     CORBA_Environment * ev)
{
   CORBA_Object_release((CORBA_Object) servant-&gt;poa, ev);

   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */ 
   <command>servant-&gt;counter=0;  /* reset */</command>
   /* ------ ---------- end ------------- ------ */

   POA_Examples_BadCall__fini((PortableServer_Servant) servant, ev);
   
   g_free (servant);
}

static Examples_BadCall_Foo
impl_Examples_BadCall_trigger(impl_POA_Examples_BadCall * servant,
			      const CORBA_long val,
			      Examples_BadCall_Foo * bar,
			      CORBA_Environment * ev)
{
   Examples_BadCall_Foo ret_val = {0.0};


   /* ------   insert method code here   ------ */
   switch ((servant-&gt;counter++) % 2)
   {
   case 0:
   {
	   /* this piece of code demonstrates how to raise exception
	    * without any further parameter */

	   Examples_BadCall_Foo dummy_foo = {0.0};

	   /* after user has assinged exception attributes, user may
	    * not touch the data anymore, ownership is handed over to
	    * CORBA environment  */
           <command>CORBA_exception_set (ev, 
				CORBA_USER_EXCEPTION,
                                ex_Examples_BadCall_NoParam,
                                NULL); /* exception has no members */
           </command>
 	   /* on exception you need not to care about out-argument
	    * @bar, but due to programming language C it is necessary
	    * to return valid value */ 
           return dummy_foo;
           break;
   }
   case 1:
   {
	   /* this piece of code demonstrates how to raise exception
	    * that has a string as parameter */

	   Examples_BadCall_Foo dummy_foo = {0.0};

	   Examples_BadCall_SingleParam* ex_parameters
		   = Examples_BadCall_SingleParam__alloc();

	   ex_parameters-&gt;mesg 
		   = CORBA_string_dup ("raised in \"" __FILE__ "\"");

	   /* after user has assinged exception attributes, user may
	    * not touch the data anymore, ownership is handed over to
	    * CORBA environment  */
         <command>  CORBA_exception_set (ev, 
				CORBA_USER_EXCEPTION,
                                ex_Examples_BadCall_SingleParam,
                                ex_parameters); /* exception has members */
         </command>
 	   /* on exception you need not to care about out-argument
	    * @bar, but due to programming language C it is necessary
	    * to return valid value */ 
           return dummy_foo;
           break;
   }
   /* this code will never raise exception DoubleParam */

   default:
           g_assert_not_reached ();
   }
   /* ------ ---------- end ------------ ------ */

   return ret_val;
}
</programlisting>
</example>
        </para>
      </sect2>
      <sect2>
	<title>Compiling client &amp; server</title>
	<para>
<example>
<title>Makefile</title>
<programlisting>PREFIX ?= /usr
CC = gcc
TARGETS=badcall-client badcall-server
ORBIT_IDL=$(PREFIX)/bin/orbit-idl-2
CFLAGS=-g -DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
         -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
         -I$(PREFIX)/lib/glib-2.0/include 
LDFLAGS= -Wl,--export-dynamic  -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm        \
             -lORBitCosNaming-2

IDLOUT=badcall-common.c badcall-stubs.c badcall-skels.c badcall.h

all: $(IDLOUT) badcall-client badcall-server

badcall-server.o: badcall-server.c badcall-skelimpl.c

badcall-client : badcall-client.o badcall-stubs.o badcall-common.o examples-toolkit.o
badcall-server : badcall-server.o badcall-skels.o badcall-common.o examples-toolkit.o

$(IDLOUT): badcall.idl
	$(ORBIT_IDL) badcall.idl

%-skelimpl.c: %.idl
	$(ORBIT_IDL) --skeleton-impl $^

clean:
	rm -rf *.o *~ $(IDLOUT) *.ior *.ref

distclean: clean
	rm -rf badcall-client badcall-server
</programlisting>
</example>
        </para>
      </sect2>
</sect1>


<sect1 id="name-resolve">
<title>NameResolve client &amp; server</title>
      <para>
<example>
<title>name-resolve.idl</title>
<programlisting role="IDL">module Examples {
	module NameResolve {
		interface Service {
			void echoString (in string input);
		};
	};
};
</programlisting>
</example>
<computeroutput>$ <command>orbit-idl-2 --skeleton-impl
name-resolve.idl</command>
</computeroutput>
geenrates all the files we will use in this example.

<informaltable>
<tgroup cols="3">
<colspec align="left"/>
<colspec align="center"/>
<colspec align="center"/>
<thead>
<row>
<entry>File</entry><entry>Usage for Client</entry><entry>Usage for Server</entry>
</row>
</thead>
<tbody>
<row>
<entry>name-resolve.h</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>name-resolve-common.c</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>name-resolve-stubs.c</entry><entry>readonly</entry><entry>-</entry>
</row>

<row>
<entry>name-resolve-skels.c</entry><entry>-</entry><entry>readonly</entry>
</row>
<row><entry>name-resolve-skelimpl.c</entry><entry>-</entry><entry>template for user code</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Files remaining to write are listed in following table, starting with 
<emphasis>name-resolve-client.c</emphasis> in following chapter.
<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>name-resolve-client.c</entry><entry>write the client code</entry>
</row>
<row>
<entry>name-resolve-server.c</entry><entry>write the generic code for servant creation</entry>
</row>
</tbody></tgroup>
</informaltable>
      </para>

<sect2>
   <title>Example-Toolkit Helpers</title>
   <para>
         <example>
            <title>example-toolkit.c(etk_get_name_service)</title>
<programlisting role="C">
 
/** resolves default name-service, usually given to application as
 * command line argument "-ORBInitRef NameService=IOR:0100000028..",
 * or since release 2.8.0 corbalocs in form of URL can be used, eg:
 * "-ORBInitRef NameService=corbaloc:iiop:HOSTNAME:PORT/NameService%00"
 */
CosNaming_NamingContext 
etk_get_name_service (CORBA_ORB         orb,
		      CORBA_Environment *ev)
{
        CORBA_char   *str=NULL;
        <command>CORBA_Object  ref
                = (CORBA_Object) CORBA_ORB_resolve_initial_references(orb,
								      "NameService",
                                                                      ev);</command>
        if (etk_raised_exception(ev)) return CORBA_OBJECT_NIL;
	
        return (CosNaming_NamingContext) ref;
}
</programlisting>
         </example>

         <example>
            <title>example-toolkit.c(etk_name_service_bind)</title>
<programlisting role="C">
/** calculate length of NULL terminated string vector */
static
guint 
id_vec_len (char *id_vec[]) 
{ 
	gint i=0; 
	for (i = 0; id_vec[i]; ++i); 
	return i;
} 

/* binds @servant object reference to unique @name at
 * @name_service. @name is a NULL terminated list of strings
 * (CORBA_char*). If error occures @ev points to exception object on
 * return.
 */
void 
etk_name_service_bind (CosNaming_NamingContext  name_service,
		       CORBA_Object             servant,
		       gchar                   *id_vec[], 
		       CORBA_Environment       *ev)
{
	gint i = 0;
	gint len = id_vec_len (id_vec);

	/* Allocate a CosNaming::Name (sequence of CosNaming::NameComponent) */
	CosNaming_Name *name = CosNaming_Name__alloc();

	name->_buffer = CORBA_sequence_CosNaming_NameComponent_allocbuf(len);
	name->_maximum = len;
	name->_length  = 0;
	
	/* Relinquish ownership of the NameComponent to the
         * sequence. When CORBA_free is called on it later, the
         * NameComponent will be freed */	
	CORBA_sequence_set_release (name, TRUE);

	/* iterate components of name and create sub-context
	 * (directory) if needed */ 
	for (i = 0; i < len; ++i) {
		name->_length = i+1;
		name->_buffer[i].id   = CORBA_string_dup(id_vec[i]);
		name->_buffer[i].kind = CORBA_string_dup(""); 
		/* don't know what 'kind' shall be good for */ 

		if (name->_length < len) 
		{
			/* create a sub-context */ 
		<command>	CosNaming_NamingContext nc = 
				CosNaming_NamingContext_bind_new_context (name_service, 
									  name, 
									  ev);	</command>
			if (etk_raised_exception_is_a (ev, 
						       ex_CosNaming_NamingContext_AlreadyBound))
			{
				/* ignore - ctx allread exists, this
				 * is not dramatic */
				CORBA_exception_free (ev);
			}
			else if (etk_raised_exception (ev)) 
			{
				/* critical - unexpected exception  */ 
				CORBA_free (name); 
				return;
			}
		}
		else
		{
			/* Bind object to last context - use 'rebind'
			 * operation in case the name has been
			 * registered allready in context - note, this
			 * might interfere with other service choosing
			 * same name */ 
		<command>	CosNaming_NamingContext_rebind (name_service, 
							name, 
							servant,
							ev);</command>
			if (etk_raised_exception(ev)) {
				/* critical - can not bind object */ 
				CORBA_free (name);
				return;
			}
		}
	}

	CORBA_free (name);
	return;
}
</programlisting>
         </example>

         <example>
            <title>example-toolkit.c(etk_name_service_resolve)</title>
<programlisting role="C">
/* resolves object reference @return with unique @name at
 *  @name_service. @name is a NULL terminated list of strings
 *  (CORBA_char*).  If error occures @ev points to * exception object
 *  on return.
 */
CORBA_Object 
etk_name_service_resolve (CosNaming_NamingContext  name_service,
			  gchar                   *id_vec[], 
			  CORBA_Environment       *ev)
{
	CORBA_Object retval = CORBA_OBJECT_NIL;
	gint i = 0;
	gint len = id_vec_len (id_vec);

	/* Allocate a CosNaming::Name (sequence of CosNaming::NameComponent) */
	CosNaming_Name *name = CosNaming_Name__alloc();

	g_assert (id_vec_len (id_vec) > 0);

	name->_buffer = CORBA_sequence_CosNaming_NameComponent_allocbuf(len);
	name->_maximum = len;
	name->_length  = 0;
	
	/* Relinquish ownership of the NameComponent to the
         * sequence. When CORBA_free is called on it later, the
         * NameComponent will be freed */	
	CORBA_sequence_set_release (name, TRUE);

	/* iterate components of name and create sub-context
	 * (directory) if needed */ 
	for (i = 0; i < len; ++i) {
		name->_length = i+1;
		name->_buffer[i].id   = CORBA_string_dup(id_vec[i]);
		name->_buffer[i].kind = CORBA_string_dup(""); 
		/* don't know what 'kind' shall be good for */ 
	}
	
<command>	retval = CosNaming_NamingContext_resolve (name_service, 
						  name, 
						  ev);</command>
	
	if (etk_raised_exception (ev)) { 
		CORBA_free (name);
		return CORBA_OBJECT_NIL;
	}
	
	return retval;
}
</programlisting>
         </example>
   </para>
</sect2>


      <sect2>
	<title>NameResolve client</title>
	<para>
<example>
<title>name-resolve-client.c</title>
<programlisting role="C">/*
 * Name-Resolve client program.. Hacked by  Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;
 *
 * Client connects to name-service and resolves object reference from server and
 * forwards console input to name-resolve-server. A dot . as single character
 * in input terminates the client.
 */

#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

/*
 * This header file was generated from the idl
 */

#include "name-resolve.h"
#include "examples-toolkit.h" /* provides etk_abort_if_exception */ 


static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
 
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
client_shutdown (int sig)
{
        CORBA_Environment  local_ev[1];
        CORBA_exception_init(local_ev);
 
        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}
 
        
/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_client_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */
static
void
client_init (int               *argc_ptr,
	     char              *argv[],
             CORBA_ORB         *orb,
             CORBA_Environment *ev)
{
        /* init signal handling */
 
        signal(SIGINT,  client_shutdown);
        signal(SIGTERM, client_shutdown);
         
        /* create Object Request Broker (ORB) */
         
        <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev);</command>
        if (etk_raised_exception(ev)) return;
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static
void
client_cleanup (CORBA_ORB                 orb,
                CORBA_Object              service,
                CORBA_Environment        *ev)
{
        /* releasing managed object */
        <command>CORBA_Object_release(service, ev);</command>
        if (etk_raised_exception(ev)) return;
 
        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                <command>CORBA_ORB_destroy(orb, ev);</command>
                if (etk_raised_exception(ev)) return;
        }
}

/**
 *
 */
static
void
client_run (Examples_NameResolve_Service  service,
	    CORBA_Environment            *ev)
{
	char filebuffer[1024+1];

	g_print("Type any text to console to be sent to server,\n"
		"a single dot in line will terminate input\n");
	
	while( fgets(filebuffer,1024,stdin) ) {
		if( filebuffer[0] == '.' &amp;&amp; filebuffer[1] == '\n' ) 
			break;
		
		/* chop the newline off */
		filebuffer[strlen(filebuffer)-1] = '\0';
      
		/* using the echoString method in the Echo object 
		 * this is defined in the echo.h header, compiled from
		 * echo.idl */

		<command>Examples_NameResolve_Service_echoString (service,
							 filebuffer,
							 ev);</command>
		if (etk_raised_exception (ev)) return;
	}
}

/*
 * main 
 */
int
main(int argc, char* argv[])
{
	Examples_NameResolve_Service service = CORBA_OBJECT_NIL;
	CosNaming_NamingContext name_service = CORBA_OBJECT_NIL;

	gchar *id[] = {"Examples", "NameResolve", "Service", NULL};

        CORBA_Environment ev[1];
        CORBA_exception_init(ev);

	<command>client_init (&amp;argc, argv, &amp;global_orb, ev);</command>
	etk_abort_if_exception(ev, "init failed");

	g_print ("Resolving service reference from name-service with id \"%s/%s/%s\"\n", id[0], id[1], id[2]);

<command>	name_service = etk_get_name_service (global_orb, ev);</command>
	etk_abort_if_exception(ev, "failed resolving name-service");

<command>	service 
	  = (Examples_NameResolve_Service) 
		etk_name_service_resolve (name_service, id, ev);</command>
	etk_abort_if_exception(ev, "failed resolving service at name-service");

	<command>client_run (service, ev);</command>
        etk_abort_if_exception(ev, "service not reachable");
 
	<command>client_cleanup (global_orb, service, ev);</command>
        etk_abort_if_exception(ev, "cleanup failed");
 
        exit (0);
}</programlisting>
</example>
         </para>
      </sect2>
      <sect2>
	<title>NameResolve server</title>
	<para>
<example>
<title>name-resolve-server.c</title>
<programlisting role="C">/*
 * echo-server program. Hacked from Echo test suite by
 * &lt;birney@sanger.ac.uk&gt;, ORBit2 udpate by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "name-resolve-skelimpl.c"
#include "examples-toolkit.h" /* provides etk_abort_if_exception */ 

static CORBA_ORB          global_orb = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA root_poa   = CORBA_OBJECT_NIL; /* root POA
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGINT,  server_shutdown);
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
        <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

        <command>(*poa) = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;

       <command> poa_manager = PortableServer_POA__get_the_POAManager(*poa, ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

	<command>PortableServer_POAManager_activate(poa_manager, ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

        <command>CORBA_Object_release ((CORBA_Object) poa_manager, ev);</command>
	return;

 failed_activation:
 failed_poamanager:
        CORBA_Object_release ((CORBA_Object) poa_manager, local_ev);
 failed_poa:
	CORBA_ORB_destroy(*orb, local_ev);		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
        <command>CORBA_ORB_run(orb, ev);</command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	<command>objid = PortableServer_POA_reference_to_id (poa, ref, ev);</command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	<command>PortableServer_POA_deactivate_object (poa, objid, ev);</command>
	if (etk_raised_exception(ev)) return;

	<command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev);</command>
	if (etk_raised_exception(ev)) return;

	CORBA_free (objid);

        <command>CORBA_Object_release ((CORBA_Object) poa, ev);</command>
	if (etk_raised_exception(ev)) return;
	
        <command>CORBA_Object_release (ref, ev);</command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                <command>CORBA_ORB_destroy(orb, ev);</command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Examples_NameResolve_Service ref = CORBA_OBJECT_NIL; 

	<command>ref = impl_Examples_NameResolve_Service__create (poa, ev);</command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	CORBA_Object servant                 = CORBA_OBJECT_NIL;
	CosNaming_NamingContext name_service = CORBA_OBJECT_NIL;

	gchar *id[] = {"Examples", "NameResolve", "Service", NULL};

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	<command>server_init (&amp;argc, argv, &amp;global_orb, &amp;root_poa, ev);</command>
	etk_abort_if_exception(ev, "failed ORB init");

	<command>servant = server_activate_service (global_orb, root_poa, ev);</command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Binding service reference at name service against id: %s/%s/%s\n\n", id[0], id[1], id[2]);
	
	<command>name_service = etk_get_name_service (global_orb, ev);</command>
	etk_abort_if_exception(ev, "failed resolving name-service");

	<command>etk_name_service_bind (name_service, servant, id, ev);</command>
	etk_abort_if_exception(ev, "failed binding of service");

	<command>server_run (global_orb, ev);</command>
	etk_abort_if_exception(ev, "failed entering main loop");

	<command>server_cleanup (global_orb, root_poa, servant, ev);</command>
	etk_abort_if_exception(ev, "failed cleanup");

	exit (0);
}
	

</programlisting>
</example>
<example>
<title>name-resolve-skelimpl.c</title>
<programlisting role="C">/* This is a template file generated by command */
/* orbit-idl-2 --skeleton-impl name-resolve.idl */
/* User must edit this file, inserting servant  */
/* specific code between markers. */

#include "name-resolve.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Examples_NameResolve_Service servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */
   /* ------ ---------- end ------------ ------ */
} impl_POA_Examples_NameResolve_Service;

/*** Implementation stub prototypes ***/

static void
impl_Examples_NameResolve_Service__fini(impl_POA_Examples_NameResolve_Service
					* servant, CORBA_Environment * ev);
static void
impl_Examples_NameResolve_Service_echoString
(impl_POA_Examples_NameResolve_Service * servant, const CORBA_char * input,
CORBA_Environment * ev);

/*** epv structures ***/

static PortableServer_ServantBase__epv
   impl_Examples_NameResolve_Service_base_epv = {
   NULL,			/* _private data */
   (gpointer) &amp; impl_Examples_NameResolve_Service__fini,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Examples_NameResolve_Service__epv
   impl_Examples_NameResolve_Service_epv = {
   NULL,			/* _private */
   (gpointer) &amp; impl_Examples_NameResolve_Service_echoString,

};

/*** vepv structures ***/

static POA_Examples_NameResolve_Service__vepv
   impl_Examples_NameResolve_Service_vepv = {
   &amp;impl_Examples_NameResolve_Service_base_epv,
   &amp;impl_Examples_NameResolve_Service_epv,
};

/*** Stub implementations ***/

static Examples_NameResolve_Service
impl_Examples_NameResolve_Service__create(PortableServer_POA poa,
					  CORBA_Environment * ev)
{
   Examples_NameResolve_Service retval;
   impl_POA_Examples_NameResolve_Service *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Examples_NameResolve_Service, 1);
   newservant-&gt;servant.vepv = &amp;impl_Examples_NameResolve_Service_vepv;
   newservant-&gt;poa =
      (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object) poa, ev);

   POA_Examples_NameResolve_Service__init((PortableServer_Servant) newservant,
					  ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

/**
 * impl_Examples_NameResolve_Service__fini
 * 
 * Destructor called after servant has been deactivated finally.
 * In case any active operation invocation, method call is being delayed.
 * Note, in former versions of ORBit2 this function would have been
 * named impl_Examples_NameResolve_Service__destroy.
**/
static void
impl_Examples_NameResolve_Service__fini(impl_POA_Examples_NameResolve_Service
					* servant, CORBA_Environment * ev)
{
   CORBA_Object_release((CORBA_Object) servant-&gt;poa, ev);

   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   POA_Examples_NameResolve_Service__fini((PortableServer_Servant) servant,
					  ev);

   g_free(servant);
}

static void
impl_Examples_NameResolve_Service_echoString
   (impl_POA_Examples_NameResolve_Service * servant, const CORBA_char * input,
    CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   <command>g_print ("&gt;&gt; %s\n", input);</command>
   /* ------ ---------- end ------------ ------ */
}
</programlisting>
</example>
        </para>
      </sect2>
      <sect2>
	<title>Compiling client &amp; server</title>
	<para>
<example>
<title>Makefile</title>
<programlisting>PREFIX ?= /usr
CC = gcc
TARGETS=name-resolve-client name-resolve-server
ORBIT_IDL=$(PREFIX)/bin/orbit-idl-2
CFLAGS=-DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
       -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
       -I$(PREFIX)/lib/glib-2.0/include -g
LDFLAGS= -Wl,--export-dynamic -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm       \
             -lORBitCosNaming-2 
IDLOUT=name-resolve-common.c name-resolve-stubs.c name-resolve-skels.c name-resolve.h

all: $(IDLOUT) name-resolve-client name-resolve-server

name-resolve-server.o: name-resolve-server.c name-resolve-skelimpl.c

name-resolve-client : name-resolve-client.o name-resolve-stubs.o name-resolve-common.o examples-toolkit.o
name-resolve-server : name-resolve-server.o name-resolve-skels.o name-resolve-common.o examples-toolkit.o name-resolve-skelimpl.o

$(IDLOUT): name-resolve.idl
	$(ORBIT_IDL) name-resolve.idl

%-skelimpl.c: %.idl
	$(ORBIT_IDL) --skeleton-impl $^

clean:
	rm -rf *.o *~ $(IDLOUT) *.ior *.ref

distclean: clean
	rm -rf name-resolve-client name-resolve-server
</programlisting>
</example>
        </para>
      </sect2>
</sect1>


<sect1 id="factory">
<title>Factory client &amp; server</title>
      <para>
<example>
<title>factory.idl</title>
<programlisting role="IDL">
module Examples {

	module Factory {

		interface AbstractService {
			void doit (in string mesg);
			void destroy ();
		};

		interface Producer {
			AbstractService produce (in string id);
		};
	};
};
</programlisting>
</example>
<computeroutput>$ <command>orbit-idl-2 --skeleton-impl
factory.idl</command>
</computeroutput>
geenrates all the files we will use in this example.

<informaltable>
<tgroup cols="3">
<colspec align="left"/>
<colspec align="center"/>
<colspec align="center"/>
<thead>
<row>
<entry>File</entry><entry>Usage for Client</entry><entry>Usage for Server</entry>
</row>
</thead>
<tbody>
<row>
<entry>factory.h</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>factory-common.c</entry><entry>readonly</entry><entry>readonly</entry>
</row>
<row>
<entry>factory-stubs.c</entry><entry>readonly</entry><entry>-</entry>
</row>

<row>
<entry>factory-skels.c</entry><entry>-</entry><entry>readonly</entry>
</row>
<row><entry>factory-skelimpl.c</entry><entry>-</entry><entry>template for user code</entry>
</row>
</tbody>
</tgroup>
</informaltable>

Files remaining to write are listed in following table, starting with 
<emphasis>factory-client.c</emphasis> in following chapter.
<informaltable>
<tgroup cols="2">
<tbody>
<row>
<entry>factory-client.c</entry><entry>write the client code</entry>
</row>
<row>
<entry>factory-server.c</entry><entry>write the generic code for servant creation</entry>
</row>
</tbody></tgroup>
</informaltable>

      </para>
      <sect2>
	<title>Factory client</title>
	<para>
<example>
<title>factory-client.c</title>
<programlisting role="C">/* factory-client.c hacked by Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.  */

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "examples-toolkit.h" /* etk_ functions */ 
#include "factory.h"


static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
 
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
client_shutdown (int sig)
{
        CORBA_Environment  local_ev[1];
        CORBA_exception_init(local_ev);
 
        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}
 
        
/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_client_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */
static
void
client_init (int               *argc_ptr,
	     char              *argv[],
             CORBA_ORB         *orb,
             CORBA_Environment *ev)
{
        /* init signal handling */
 
        signal(SIGINT,  client_shutdown);
        signal(SIGTERM, client_shutdown);
         
        /* create Object Request Broker (ORB) */
         
        <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev);</command>
        if (etk_raised_exception(ev)) return;
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static
void
client_cleanup (CORBA_ORB                 orb,
                CORBA_Object              servant,
                CORBA_Environment        *ev)
{
        /* releasing managed object */
        <command>CORBA_Object_release(servant, ev);</command>
        if (etk_raised_exception(ev))
		return;
 
        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                <command>CORBA_ORB_destroy(orb, ev);</command>
                if (etk_raised_exception(ev)) 
			return;
        }
}

/**
 *
 */
static
void
client_run (Examples_Factory_Producer     factory,
	    CORBA_Environment            *ev)
{
	#define MAX_ID_LEN 100

	CORBA_char  service_id [MAX_ID_LEN+1] = "";
	gint i = 0;
	gint j = 0;

	for (i = 0; i&lt;20; ++i)
	{
		snprintf (service_id, MAX_ID_LEN, "id-%d", i);

		g_printf ("abstract-service: create,");
		<command>Examples_Factory_AbstractService service 
			= Examples_Factory_Producer_produce (factory, 
							     service_id, 
							     ev);</command>
		if (etk_raised_exception (ev)) 
			return;
		
		for (j = 0; j &lt; 5; ++j)
		{
			g_printf (" apply,");

			CORBA_char *mesg = "hallo welt";
			<command>Examples_Factory_AbstractService_doit (service, 
							       mesg, 
							       ev);</command>
			if (etk_raised_exception (ev)) 
				return;
		}

		g_printf (" destroy\n");

		<command>Examples_Factory_AbstractService_destroy (service, ev);</command>
		if (etk_raised_exception (ev)) 
			return;

		<command>CORBA_Object_release ((CORBA_Object) service, ev);</command>
		if (etk_raised_exception (ev)) 
			return;

	}
	#undef MAX_IDL_LEN
}

/*
 * main 
 */
int
main(int argc, char* argv[])
{
        CORBA_char filename[] = "factory.ref";
         
        Examples_Factory_Producer producer = CORBA_OBJECT_NIL;
 
        CORBA_Environment ev[1];
        CORBA_exception_init(ev);
 
        <command>client_init (&amp;argc, argv, &amp;global_orb, ev);</command>
        etk_abort_if_exception(ev, "init failed");
 
        g_print ("Reading service reference from file \"%s\"\n", filename);
 
        <command>producer 
          = (Examples_Factory_Producer) 
		etk_import_object_from_file (global_orb,
					     filename,
					     ev);</command>
        etk_abort_if_exception(ev, "import service failed");
 
        <command>client_run (producer, ev);</command>
        etk_abort_if_exception(ev, "service not reachable");
  
        <command>client_cleanup (global_orb, producer, ev);</command>
        etk_abort_if_exception(ev, "cleanup failed");
  
        exit (0);
}</programlisting>
</example>
         </para>
      </sect2>
      <sect2>
	<title>Factory server</title>
	<para>
<example>
<title>factory-server.c</title>
<programlisting role="C">/*
 * factory-server program. Hacked by Frank
 * Rehberger &lt;F.Rehberger@xtradyne.de&gt;
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;
#include &lt;ORBitservices/CosNaming.h&gt;

#include "factory.h"
#include "factory-skelimpl.c" 

#include "examples-toolkit.h" /* etk_ functions */ 

static CORBA_ORB          global_orb = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA root_poa   = CORBA_OBJECT_NIL; /* root POA
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGINT,  server_shutdown);
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
        <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

        <command>(*poa) = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;

       <command> poa_manager = PortableServer_POA__get_the_POAManager(*poa, ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

<command>	PortableServer_POAManager_activate(poa_manager, ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

        <command>CORBA_Object_release ((CORBA_Object) poa_manager, ev);</command>
	return;

 failed_activation:
 failed_poamanager:
        CORBA_Object_release ((CORBA_Object) poa_manager, local_ev);
 failed_poa:
	CORBA_ORB_destroy(*orb, local_ev);		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
        <command>CORBA_ORB_run(orb, ev);</command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	<command>objid = PortableServer_POA_reference_to_id (poa, ref, ev);</command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	<command>PortableServer_POA_deactivate_object (poa, objid, ev);</command>
	if (etk_raised_exception(ev)) return;

	<command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev);</command>
	if (etk_raised_exception(ev)) return;

	CORBA_free (objid);

        <command>CORBA_Object_release ((CORBA_Object) poa, ev);</command>
	if (etk_raised_exception(ev)) return;
	
        <command>CORBA_Object_release (ref, ev);</command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                <command>CORBA_ORB_destroy(orb, ev);</command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Examples_Factory_Producer ref = CORBA_OBJECT_NIL; 

	<command>ref = impl_Examples_Factory_Producer__create (poa, ev);</command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	CORBA_Object servant = CORBA_OBJECT_NIL;
	
	CORBA_char filename[] = "factory.ref";

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	<command>server_init (&amp;argc, argv, &amp;global_orb, &amp;root_poa, ev);</command>
	etk_abort_if_exception(ev, "failed ORB init");

	<command>servant = server_activate_service (global_orb, root_poa, ev);</command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Writing service reference to: %s\n\n", filename);

	<command>etk_export_object_to_file (global_orb, 
				   servant, 
				   filename, 
				   ev);</command>
	etk_abort_if_exception(ev, "failed exporting IOR");
	
	<command>server_run (global_orb, ev);</command>
	etk_abort_if_exception(ev, "failed entering main loop");

	<command>server_cleanup (global_orb, root_poa, servant, ev);</command>
	etk_abort_if_exception(ev, "failed cleanup");

	exit (0);
}</programlisting>
</example>
<example>
<title>factory-skelimpl.c</title>
<programlisting role="C">/*
 * This is a template file generated by command 
 * orbit-idl-2 --skeleton-impl name-resolve.idl 
 * User must edit this file, inserting servant 
 * specific code between markers. 
 */

#include "factory.h"

/*** App-specific servant structures ***/

typedef struct
{
  POA_Examples_Factory_AbstractService servant;
  PortableServer_POA poa;

  /* ------ add private attributes here ------  */
  <command>CORBA_char *id;
  CORBA_long counter;</command>
  /* ------ ---------- end ------------ ------  */
} impl_POA_Examples_Factory_AbstractService;

typedef struct
{
  POA_Examples_Factory_Producer servant;
  PortableServer_POA poa;

  /* ------ add private attributes here ------ */
  /* ------ ---------- end ------------ ------ */
} impl_POA_Examples_Factory_Producer;

/*** Implementation stub prototypes ***/

static void
  impl_Examples_Factory_AbstractService__fini
  (impl_POA_Examples_Factory_AbstractService * servant,
   CORBA_Environment * ev);
static void
  impl_Examples_Factory_AbstractService_doit
  (impl_POA_Examples_Factory_AbstractService * servant,
   const CORBA_char * mesg, CORBA_Environment * ev);

static void
  impl_Examples_Factory_AbstractService_destroy
  (impl_POA_Examples_Factory_AbstractService * servant,
   CORBA_Environment * ev);

static void
  impl_Examples_Factory_Producer__fini
  (impl_POA_Examples_Factory_Producer * servant, CORBA_Environment * ev);
static Examples_Factory_AbstractService
  impl_Examples_Factory_Producer_produce
  (impl_POA_Examples_Factory_Producer * servant, const CORBA_char * id,
   CORBA_Environment * ev);

/*** epv structures ***/

static PortableServer_ServantBase__epv
  impl_Examples_Factory_AbstractService_base_epv = {
  NULL,				/* _private data */
  (gpointer) &amp; impl_Examples_Factory_AbstractService__fini,	/* finalize routine */
  NULL,				/* default_POA routine */
};
static POA_Examples_Factory_AbstractService__epv
  impl_Examples_Factory_AbstractService_epv = {
  NULL,				/* _private */
  (gpointer) &amp; impl_Examples_Factory_AbstractService_doit,

  (gpointer) &amp; impl_Examples_Factory_AbstractService_destroy,

};
static PortableServer_ServantBase__epv
  impl_Examples_Factory_Producer_base_epv = {
  NULL,				/* _private data */
  (gpointer) &amp; impl_Examples_Factory_Producer__fini,	/* finalize routine */
  NULL,				/* default_POA routine */
};
static POA_Examples_Factory_Producer__epv impl_Examples_Factory_Producer_epv = {
  NULL,				/* _private */
  (gpointer) &amp; impl_Examples_Factory_Producer_produce,

};

/*** vepv structures ***/

static POA_Examples_Factory_AbstractService__vepv
  impl_Examples_Factory_AbstractService_vepv = {
  &amp;impl_Examples_Factory_AbstractService_base_epv,
  &amp;impl_Examples_Factory_AbstractService_epv,
};
static POA_Examples_Factory_Producer__vepv
  impl_Examples_Factory_Producer_vepv = {
  &amp;impl_Examples_Factory_Producer_base_epv,
  &amp;impl_Examples_Factory_Producer_epv,
};

/*** Stub implementations ***/

static Examples_Factory_AbstractService
impl_Examples_Factory_AbstractService__create (PortableServer_POA poa,
					       const CORBA_char * id,
					       CORBA_Environment * ev)
{
  Examples_Factory_AbstractService retval;
  impl_POA_Examples_Factory_AbstractService *newservant;
  PortableServer_ObjectId *objid;

  newservant = g_new0 (impl_POA_Examples_Factory_AbstractService, 1);
  newservant-&gt;servant.vepv = &amp;impl_Examples_Factory_AbstractService_vepv;
  newservant-&gt;poa =
    (PortableServer_POA) CORBA_Object_duplicate ((CORBA_Object) poa, ev);
  POA_Examples_Factory_AbstractService__init ((PortableServer_Servant)
					      newservant, ev);
  /*
   * Before servant is going to be activated all private attributes must 
   * be initialized.  
   */

  /* ------ init private attributes here ------ */
  <command>newservant-&gt;id = CORBA_string_dup (id);
  newservant-&gt;counter = 0;</command>
  /* ------ ---------- end ------------- ------ */

  objid = PortableServer_POA_activate_object (poa, newservant, ev);
  CORBA_free (objid);
  retval = PortableServer_POA_servant_to_reference (poa, newservant, ev);

  return retval;
}

/**
 * impl_Exampels_Factory_AbstractService__fini
 * 
 * Destructor called after servant has been deactivated finally.
 * In case any operation invocation, method invoation is being delayed.
 * Note, in former versions of ORBit2 this function would have been 
 * named impl_Exampels_Factory_AbstractService__destroy.
**/
static void
  impl_Examples_Factory_AbstractService__fini
  (impl_POA_Examples_Factory_AbstractService * servant,
   CORBA_Environment * ev)
{
  CORBA_Object_release ((CORBA_Object) servant-&gt;poa, ev);

  /*
   * No further remote method calls are delegated to servant and you
   * may free your private attributes. 
   */
  /* ------ free private attributes here ------  */
  <command>CORBA_free (servant-&gt;id);</command>
  /* ------ ---------- end ------------- ------  */

  POA_Examples_Factory_AbstractService__fini ((PortableServer_Servant)
					      servant, ev);

  g_free (servant);
}

static void
  impl_Examples_Factory_AbstractService_doit
  (impl_POA_Examples_Factory_AbstractService * servant,
   const CORBA_char * mesg, CORBA_Environment * ev)
{
  /* ------ insert method code here ------ */
  <command>g_print ("service-id=\"%s\", nth-call=\"%d\", \n", 
	   servant-&gt;id, 
	   servant-&gt;counter);
  ++(servant-&gt;counter);</command>
  /* ------ ---------- end ------------ ------  */
}


static void
deactivate_servant (PortableServer_POA poa,
		    PortableServer_Servant servant, CORBA_Environment * ev)
{
 <command> PortableServer_ObjectId *id
    = PortableServer_POA_servant_to_id (poa, servant, ev);

  if (etk_raised_exception (ev))
    return;

  PortableServer_POA_deactivate_object (poa, id, ev);

  /* free id in any case  */
  g_free (id);</command>
}

static void
  impl_Examples_Factory_AbstractService_destroy
  (impl_POA_Examples_Factory_AbstractService * servant,
   CORBA_Environment * ev)
{
  /* ------ insert method code here ------ */
  <command>deactivate_servant (servant-&gt;poa, servant, ev);</command>
  /* ------ ---------- end ------------ ------ */
}

static Examples_Factory_Producer
impl_Examples_Factory_Producer__create (PortableServer_POA poa,
					CORBA_Environment * ev)
{
  Examples_Factory_Producer retval;
  impl_POA_Examples_Factory_Producer *newservant;
  PortableServer_ObjectId *objid;

  newservant = g_new0 (impl_POA_Examples_Factory_Producer, 1);
  newservant-&gt;servant.vepv = &amp;impl_Examples_Factory_Producer_vepv;
  newservant-&gt;poa =
    (PortableServer_POA) CORBA_Object_duplicate ((CORBA_Object) poa, ev);
  POA_Examples_Factory_Producer__init ((PortableServer_Servant)
				       newservant, ev);
  /*
   * Before servant is going to be activated all private attributes must 
   * be initialized.  
   */

  /* ------ init private attributes here ------ */ 
  /* ------ ---------- end ------------- ------ */

  objid = PortableServer_POA_activate_object (poa, newservant, ev);
  CORBA_free (objid);
  retval = PortableServer_POA_servant_to_reference (poa, newservant, ev);

  return retval;
}

/**
 * impl_Examples_Factory_Producer__fini
 * 
 * Destructor called after servant has been deactivated finally.
 * In case any operation invocation, method invoation is being delayed.
 * Note, in former versions of ORBit2 this function would have been 
 * named impl_Exampels_Factory_Producer__destroy
**/
static void
  impl_Examples_Factory_Producer__fini
  (impl_POA_Examples_Factory_Producer * servant, CORBA_Environment * ev)
{
  CORBA_Object_release ((CORBA_Object) servant-&gt;poa, ev);

  /*
   * No further remote method calls are delegated to servant and you
   * may free your private attributes. 
   */ 
  /* ------ free private attributes here ------  */
  /* ------ ---------- end ------------- ------ */

  POA_Examples_Factory_Producer__fini ((PortableServer_Servant) servant, ev);

  g_free (servant);
}

static Examples_Factory_AbstractService
  impl_Examples_Factory_Producer_produce
  (impl_POA_Examples_Factory_Producer * servant, const CORBA_char * id,
   CORBA_Environment * ev)
{
  Examples_Factory_AbstractService retval;

  /* ------ insert method code here ------ */
<command>  retval =
    impl_Examples_Factory_AbstractService__create (servant-&gt;poa, id, ev);
  if (etk_raised_exception (ev))
    {
      retval = CORBA_OBJECT_NIL;
    }</command>
  /* ------ ---------- end ------------ ------  */

  return retval;
}
</programlisting>
</example>
        </para>
      </sect2>
      <sect2>
	<title>Compiling client &amp; server</title>
	<para>
<example>
<title>Makefile</title>
<programlisting>PREFIX ?= /usr
CC = gcc
TARGETS=factory-client factory-server
ORBIT_IDL=$(PREFIX)/bin/orbit-idl-2
CFLAGS=-g -DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
         -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
         -I$(PREFIX)/lib/glib-2.0/include 
LDFLAGS= -Wl,--export-dynamic  -L$(PREFIX)/lib -lORBitCosNaming-2 -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm
IDLOUT=factory-common.c factory-stubs.c factory-skels.c factory.h

all: $(IDLOUT) factory-client factory-server

factory-server.o: factory-server.c factory-skelimpl.c

factory-client : factory-client.o factory-stubs.o factory-common.o examples-toolkit.o
factory-server : factory-server.o factory-skels.o factory-common.o examples-toolkit.o

$(IDLOUT): factory.idl
	$(ORBIT_IDL) factory.idl

%-skelimpl.c: %.idl
	$(ORBIT_IDL) --skeleton-impl $^

clean:
	rm -rf *.o *~ $(IDLOUT) *.ior *.ref

distclean: clean
	rm -rf factory-client factory-server
</programlisting>
</example>
        </para>
      </sect2>
</sect1>

<sect1 id="threaded_server">
<title>Threaded calculator server</title>
      <para>
Lets take the calculator-server from previous chapter to demonstrate ORBit2
in multi threaded environment.

<example>
<title></title>
<programlisting role="IDL">
//
// Calculator interface
//

interface Calculator
{
      double add(in double number1, in double number2);
      double sub(in double number1, in double number2);
};
</programlisting>
</example>
      </para>

      <sect2>
	<title>multi-threaded calculator server</title>
	<para>
<example>
<title>mt-calculator-server.c</title>
<programlisting role="C">/*
 * calculator-server program. Hacked from Frank Rehberger
 * &lt;F.Rehberger@xtradyne.de&gt;.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;orbit/orbit.h&gt;

#include "calculator.h"
#include "calculator-skelimpl.c"

#include "examples-toolkit.h"

static CORBA_ORB          global_orb  = CORBA_OBJECT_NIL; /* global orb */
static PortableServer_POA default_poa = CORBA_OBJECT_NIL; /* default POA */
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                <command>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</command>
                etk_abort_if_exception (local_ev, "caught exception");
        }
}

/**

 */
PortableServer_POA
server_create_multi_threaded_poa (CORBA_ORB                  orb, 
				  PortableServer_POA         poa,
				  PortableServer_POAManager  poa_mgr,
				  CORBA_Environment         *ev)
{
	const static        MAX_POLICIES  = 1;
	PortableServer_POA  child_poa     = CORBA_OBJECT_NIL;
	CORBA_PolicyList   *poa_policies;

	<command>poa_policies           = CORBA_PolicyList__alloc ();
        poa_policies-&gt;_maximum = MAX_POLICIES;
        poa_policies-&gt;_length  = MAX_POLICIES;
        poa_policies-&gt;_buffer  = CORBA_PolicyList_allocbuf (MAX_POLICIES);
        CORBA_sequence_set_release (poa_policies, CORBA_TRUE);</command>
                                                                                
        <command>poa_policies-&gt;_buffer[0] = (CORBA_Policy)
		PortableServer_POA_create_thread_policy (
			poa,
			PortableServer_ORB_CTRL_MODEL,
			ev);</command>

	<command>child_poa = PortableServer_POA_create_POA (poa,
                                                   "Thread Per Request POA",
                                                   poa_mgr,
                                                   poa_policies,
                                                   ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_create_poa;

	<command>ORBit_ObjectAdaptor_set_thread_hint ((ORBit_ObjectAdaptor) child_poa, 
					     ORBIT_THREAD_HINT_PER_REQUEST);</command>

	
        <command>CORBA_Policy_destroy (poa_policies-&gt;_buffer[0], ev); </command>
	if (etk_raised_exception(ev)) 
		goto failed;
        <command>CORBA_free (poa_policies);	</command>
	
	return child_poa;
	
 failed_create_poa:
	/* FIXME, in case of error, ev is set, but destructor should not
	 * return except anyway */
        <command>CORBA_Policy_destroy (poa_policies-&gt;_buffer[0], ev); </command>
        <command>CORBA_free (poa_policies);</command>	
 failed:
	return CORBA_OBJECT_NIL;
}


/* Inits ORB @orb using @argv arguments for configuration. For each
 * ORBit options consumed from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * echo_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
server_init (int                 *argc_ptr, 
	     char                *argv[],
	     CORBA_ORB           *orb,
	     PortableServer_POA  *poa,
	     CORBA_Environment   *ev)
{
	PortableServer_POA         rootpoa     = CORBA_OBJECT_NIL;
	PortableServer_POAManager  rootpoa_mgr = CORBA_OBJECT_NIL; 

	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

	/* init signal handling */
	signal(SIGTERM, server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
        <command>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-mt-orb", ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_orb;

        <command>rootpoa = (PortableServer_POA) 
		CORBA_ORB_resolve_initial_references(*orb, "RootPOA", ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_poa;
	
        <command>rootpoa_mgr = PortableServer_POA__get_the_POAManager(rootpoa, ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_poamanager;

	/* create default POA with specific policies */

	<command>(*poa) = server_create_multi_threaded_poa (*orb, 
						   rootpoa, 
						   rootpoa_mgr, 
						   ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_child_poa;

	<command>PortableServer_POAManager_activate(rootpoa_mgr, ev);</command>
	if (etk_raised_exception(ev)) 
		goto failed_activation;

        CORBA_Object_release ((CORBA_Object) rootpoa_mgr, ev);
	return;

 failed_activation:
 failed_child_poa:
 failed_poamanager:
        <command>CORBA_Object_release ((CORBA_Object) rootpoa_mgr, local_ev);</command>
 failed_poa:
	<command>CORBA_ORB_destroy(*orb, local_ev);</command>		
 failed_orb:
	return;
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static void 
server_run (CORBA_ORB          orb,
	    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
        <command>CORBA_ORB_run(orb, ev);</command>
	if (etk_raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static void 
server_cleanup (CORBA_ORB           orb,
		PortableServer_POA  poa,
		CORBA_Object        ref,
		CORBA_Environment  *ev)
{
	PortableServer_ObjectId   *objid       = NULL;

	<command>objid = PortableServer_POA_reference_to_id (poa, ref, ev);</command>
	if (etk_raised_exception(ev)) return;
		
	/* Servant: deactivatoin - will invoke  __fini destructor */
	<command>PortableServer_POA_deactivate_object (poa, objid, ev);</command>
	if (etk_raised_exception(ev)) return;

	<command>PortableServer_POA_destroy (poa, TRUE, FALSE, ev);</command>
	if (etk_raised_exception(ev)) return;

	<command>CORBA_free (objid);</command>

        <command>CORBA_Object_release ((CORBA_Object) poa, ev);</command>
	if (etk_raised_exception(ev)) return;
	
        <command>CORBA_Object_release (ref, ev);</command>
	if (etk_raised_exception(ev)) return;

        /* ORB: tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                <command>CORBA_ORB_destroy(orb, ev);</command>
		if (etk_raised_exception(ev)) return;
        }
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static CORBA_Object
server_activate_service (CORBA_ORB           orb,
			 PortableServer_POA  poa,
			 CORBA_Environment  *ev)
{
	Calculator  ref = CORBA_OBJECT_NIL; 

	<command>ref = impl_Calculator__create (poa, ev);</command>
	if (etk_raised_exception(ev)) 
		return CORBA_OBJECT_NIL;
	
	return ref;
}

/* 
 * background task 
 */
typedef struct {
	int    argc;
	char **argv;
} BackgroundData;

static gpointer
server_in_background (BackgroundData *data)
{
	int    argc = data-&gt;argc;
	char **argv = data-&gt;argv;

	CORBA_Object servant = CORBA_OBJECT_NIL;
	
	CORBA_char filename[] = "calculator.ref";

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	<command>server_init (&amp;argc, argv, &amp;global_orb, &amp;default_poa, ev);</command>
	etk_abort_if_exception(ev, "failed ORB init");

	<command>servant = server_activate_service (global_orb, default_poa, ev);</command>
	etk_abort_if_exception(ev, "failed activating service");

	g_print ("Writing service reference to: %s\n\n", filename);

	<command>etk_export_object_to_file (global_orb, 
				   servant, 
				   filename, 
				   ev);</command>
	etk_abort_if_exception(ev, "failed exporting IOR");
	
	<command>server_run (global_orb, ev);</command>
	etk_abort_if_exception(ev, "failed entering main loop");

	<command>server_cleanup (global_orb, default_poa, servant, ev);</command>
	etk_abort_if_exception(ev, "failed cleanup");

	g_thread_exit (NULL);
}

static
void
main_shutdown (int sig)
{
	/* progate SIGTERM signal to every process/thread in process
	 * group */ 
	kill (0, 15);
	
	/* terminate main thread */ 
	exit (0);
}

/* 
 * main 
 */
int 
main (int argc, char *argv[])
{
	BackgroundData data[1];
	gint     i      = 0;
	GError  *err    = NULL;
	GThread *thread = NULL;

	g_thread_init (NULL);

	data-&gt;argc = argc;
	data-&gt;argv = argv;

	<command>thread = g_thread_create ((GThreadFunc) server_in_background, 
				  data, 
				  TRUE,   /*joinable */
				  &amp;err);</command>

	/* init signal handling */
	signal(SIGINT,  main_shutdown);
	signal(SIGHUP,  main_shutdown);
	
	/* concurrent main task */ 
	while (i++ &lt; 1000) {
		g_print ("main thread active\n");
		sleep (1);
	}
	
	g_print ("main thread waiting for background task\n");
	g_thread_join (thread);
	
	exit (0);	
}

</programlisting>
</example>
In this case calculator-skelimpl.c file can be kept as before, no
changes are necessary. But if servants would share common resource, it
would be necessary to protect critical code sections with muteces
(locks).
<example>
<title>calculator-skelimpl.c</title>
<programlisting role="C">#include "calculator.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Calculator servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */
   /* ------ ---------- end ------------ ------ */
}
impl_POA_Calculator;

/*** Implementation stub prototypes ***/

static void impl_Calculator__fini (impl_POA_Calculator * servant,
				   CORBA_Environment * ev);
static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, CORBA_Environment * ev);

static CORBA_double
impl_Calculator_sub(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, CORBA_Environment * ev);

/*** epv structures ***/

static PortableServer_ServantBase__epv impl_Calculator_base_epv = {
   NULL,			/* _private data */
   (gpointer) &amp; impl_Calculator__fini,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Calculator__epv impl_Calculator_epv = {
   NULL,			/* _private */
   (gpointer) &amp; impl_Calculator_add,

   (gpointer) &amp; impl_Calculator_sub,

};

/*** vepv structures ***/

static POA_Calculator__vepv impl_Calculator_vepv = {
   &amp;impl_Calculator_base_epv,
   &amp;impl_Calculator_epv,
};

/*** Stub implementations ***/

static Calculator
impl_Calculator__create (PortableServer_POA poa, CORBA_Environment * ev)
{
   Calculator retval;
   impl_POA_Calculator *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Calculator, 1);
   newservant-&gt;servant.vepv = &amp;impl_Calculator_vepv;
   newservant-&gt;poa =       
      (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object) poa, ev);
   POA_Calculator__init((PortableServer_Servant) newservant, ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

/**
 * impl_Calculator__fini
 * 
 * Destructor called after servant has been deactivated finally.
 * In case any operation invocation, method invoation is being delayed.
 * Note, in former versions of ORBit2 this function would have been 
 * named impl_Calculator__destroy.
 **/
static void
impl_Calculator__fini (impl_POA_Calculator * servant,
		       CORBA_Environment * ev)
{
   CORBA_Object_release((CORBA_Object) servant-&gt;poa, ev);
 
   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   POA_Calculator__fini((PortableServer_Servant) servant, ev);
   
   g_free (servant);
}

static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   g_print ("%f + %f\n", number1, number2);
   retval = number1 + number2;
   /* ------ ---------- end ------------ ------ */

   return retval;
}

static CORBA_double
impl_Calculator_sub(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   g_print ("%f - %f\n", number1, number2);
   retval = number1 - number2;
   /* ------ ---------- end ------------ ------ */

   return retval;
}
</programlisting>
</example>
        </para>
      </sect2>
      <sect2>
	<title>Compiling client &amp; server</title>
	<para>
<example>

<title>Makefile</title>
<programlisting>PREFIX ?= /usr
CC = gcc
TARGETS=calculator-client mt-calculator-server
ORBIT_IDL=$(PREFIX)/bin/orbit-idl-2
CFLAGS=-DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
       -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
       -I$(PREFIX)/lib/glib-2.0/include -g
LDFLAGS= -Wl,--export-dynamic -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm       \
	     -lORBitCosNaming-2 

IDLOUT=calculator-common.c calculator-stubs.c calculator-skels.c calculator.h

all: $(IDLOUT) calculator-client mt-calculator-server

mt-calculator-server.o : mt-calculator-server.c calculator-skelimpl.c

calculator-client : calculator-client.o calculator-stubs.o calculator-common.o examples-toolkit.o 
mt-calculator-server : mt-calculator-server.o calculator-skels.o calculator-common.o examples-toolkit.o 

$(IDLOUT): calculator.idl
	$(ORBIT_IDL) calculator.idl

%-skelimpl.c: %.idl
	$(ORBIT_IDL) --skeleton-impl $^

clean:
	rm -rf *.o *~ $(IDLOUT) *.ior *.ref

distclean: clean
	rm -rf calculator-client mt-calculator-server
</programlisting>
</example>
        </para>
      </sect2>
</sect1>

<!--
<sect1 id="nameservice">
<title>NameService client &amp; server</title>
      <para>
<example>
<title>XXXX</title>
<programlisting role="IDL"></programlisting>
</example>
      </para>
      <sect2>
	<title>NameService client</title>
	<para>
<example>
<title>XXXX</title>
<programlisting role="C"></programlisting>
</example>
         </para>
      </sect2>
      <sect2>
	<title>NameService server</title>
	<para>
<example>
<title>XXXX</title>
<programlisting role="C"></programlisting>
</example>
<example>
<title></title>
<programlisting role="C"></programlisting>
</example>
        </para>
      </sect2>
      <sect2>
	<title>Compiling client &amp; server</title>
	<para>
<example>
<title>XXXX</title>
<programlisting></programlisting>
</example>
        </para>
      </sect2>
</sect1>
-->
<!-- 
*************************  ORBIT and GNOME *****************************************
-->

</chapter>

<!--
<chapter>
<title>Bonobo:: GNOME Component Framework</title>
<para>

</para>
</chapter>
-->

<chapter>
<title>How to do garbage collection under CORBA</title>
<para>
I wanted to do garbage collection under CORBA, and so I asked some questions
 on the ORBit list. Here is a distillation of the answers which I received,
 mostly verbatim and not necessarily in order.
</para>
<para>
Editor's note - this chapter came from Todd Lewis
</para>
<sect1>
<title>The question</title>
<para>
I asked the following question on the ORBit list:
</para>
<para>
<quote>As a client, when I no longer need an object, how do I properly release
 it? I see a couple of different candidate functions, but I'm not sure which
 one is proper. If there's a piece of example code which I've overlooked, then
 a simple pointer thereto would suffice. My copy of the Henning &amp; Vinoski
 book is on the way, and so hopefully I won't be so clueless here soon...
</quote>
</para>
</sect1>
<sect1>
<title>Difference between the client and the server</title>
<para>

Elliot Lee, ever the prescient one, asked:
</para>
<para>
<quote>Object or object reference?
</quote>
</para>
<para>
And then observed:
</para>
<para>
<quote>I think Todd is confused as to what the difference between object references
 and objects is. Think of an object reference and an object as being analogous
 to a pointer and pointed-to memory, respectively. You can stop using a pointer,
 but until you get the server side to actually free() the memory (object) being
 pointed to (referenced), it is still there.
</quote>
</para>
<para>
Indeed I was confused. There are actually two processes which occur within
 CORBA:
<itemizedlist>
<listitem><para>the client drops all references to an object, after which the ORB local
 to the client then can clean up all of its data structures related to that
object, and </para>
</listitem>

<listitem><para>the server can decide that the object needs to be destroyed, and it then
 does the job of deactivating the object (so that the POA can know not to answer
 any more queries to that object) and freeing associated resources, etc. 
</para></listitem>
</itemizedlist>
</para> 
<para>
Since object references can be generated in one program, passed to a second
 program, the first program can forget about it, and the second can continue,
 these are separate processes. It was understanding this fact which was the
 biggest impediment to my figuring this matter out.
</para>
<para>
Sascha Brawer &lt;brawer@coli.uni-sb.de&gt; described these two potential
 interpretations of what I wanted to do, reflecting a nuance which I did not
 appreciate when I asked the question:
</para>
<para>
<itemizedlist>
<listitem><para>You want the client to forget about the object reference, but the server-side
 object should continue its life: Call CORBA_free on the client side. The purpose
 of CORBA_free is to release the memory in the client. Therefore, the server
 will not get any notification about this. If other clients had references to
 the same object, they will continue to work.
</para></listitem>
<listitem><para> You want to destroy the object on the server: define a method in the
 object's interface, e.g. "destroy" (though any name is fine). First, call that
 method on the client side. The server will receive the call, and your server
 implementation will destroy the object. Second, call CORBA_free on the client
 side, to free the client-side memory for the object reference which has now
 become stale. If other clients had references to the same object, they will
 receive an exception as soon they call a method on that object. However, they
 won't be notified in advance, because the server does not keep track on issued
 references.
</para></listitem>
</itemizedlist>
</para>
<para>
Which Elliot Lee then corrected with:
</para>
<para>
CORBA_Object_release() on object references, CORBA_free() on data structures.
</para>
<para>
Dick Porter added:
</para><para>
It is _only_ the client side. These pseudo-object methods do not cause requests
to be made to the server.
</para>
</sect1>
<sect1><title>Server-side deactivation</title>
<para>
Ok, so CORBA_Object_release takes care of the client side. This isn't enough,
 because, as Elliot Lee pointed out, to state the point slightly differently:
<programlisting>
On Tue, 20 Apr 1999, Svanberg Liss wrote:
&gt; Btw, what does CORBA_Object_duplicate &amp; CORBA_Object_release do
&gt; server?

Nothing..
</programlisting>

So, what do you do on the server side? Elliot answered this, too:
<programlisting>
&gt; and... hmm, what kind of call does destroy the object in the server
 when 
&gt; release doesn't?

You PortableServer_POA_deactivate_object(poa, objid) to tell the POA not
to take any more requests for the specified objid.
</programlisting>

Let's take a look at what this means in terms of actual code. If you run
<userinput>
orbit-idl --skeleton_impl foo.idl
</userinput>

on your idl file, you will get a file foo-impl.c. Inside of that file,
 you will see functions like the following:
<programlisting role="C">
/* You shouldn't call this routine directly without first deactivating
 the servant... */

static void

impl_CosTransactions_Control__destroy(

     impl_POA_CosTransactions_Control * servant, 

     CORBA_Environment * ev)

{

   POA_CosTransactions_Control__fini((PortableServer_Servant) servant,
 ev);

   g_free(servant);

}
</programlisting>

Where it says "You shouldn't call this routine directly without first
 deactivating the servant...", it means that you should call PortableServer_POA_deactivate_object()
 on the servant first.
</para>

<para>
FIXME: I don't understand what POA_CosTransactions_Control__fini does here;
 how is it different from PortableServer_POA_deactivate_object? Anyway, this
 is the final step you take after your object is deactivated; you can then free
 the POA servant struct which you created in your factory (or wherever.)
</para>
</sect1>
<sect1><title>Why is this an issue?</title>

<formalpara>
<title>Sascha Brawer suggests:</title>
<para>
Maybe the confusion arises because there do exist distributed object systems
 that perform this sort of reference counting, allowing the server to know when
 no client has a reference left. DCOM has such a mechanism, and ILU has something
 similar, AFAIK.
</para>
</formalpara>
<para>
Why doesn't CORBA follow these other systems? My personal impression is
 that this is another case of CORBA doing the right thing instead of the easy
 thing. Sascha continues:
</para>
<para>
However, I've read somewhere (don't remeber the exact location, sorry...)
 that the problem with distributed reference counting would be that first, it
 consumes network bandwith, and second, it does not work well with unreliable
 network connections. It was told in that article that these drawbacks would
 have been the rationale for designing CORBA without refcounting.
</para>
<para>
This is a problem. If your client disappears, then you've got unneeded
 objects lying around. All it takes for clients to disappear is for
 them to be coded by bad programmers, and we all know how unlikely
 that is, right? So how does one deal with this? There are several
 ways. The easiest is to have a timeout.  This is the approach that I
 am using in the GNU Transaction Server; when the timeout expires, I
 deactivate all of my servant objects and free up their resources.
 Fortunately, the CosTransactions spec supports timeouts on
 transactions. Unfortunately, I don't really see how to do timeouts
 with the normal CORBA event model, so I'm going to have to use the
 ORBit-specific hack of having a glib event loop which supports both
 CORBA events and timeouts. Another way, I am told, is something
 called an Evictor pattern. I should understand this soon once I get
 my fancy CORBA book in the mail. The final way is just to leak memory
 like a sieve leaks goldfish; this is the easiest thing to do.
</para>
</sect1>
</chapter>
</book>





