<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>GConf configuration system</title>
</head>
<body>
<h1>GConf configuration system</h1>

<p>GConf is a system for storing application preferences. It is
intended for user preferences; <em>not</em> configuration of something
like Apache, or arbitrary data storage.

<h2>Documentation</h2> 

<p>This page introduces GConf - read on for some simple docs and FAQs
and troubleshooting information. The GConf reference manual is sort of
incomplete - a slightly old version can be found at <a
href="http://developer.gnome.org/doc/API/">http://developer.gnome.org/doc/API/</a>. For
now you should really use the version in the GConf tarball instead, it
has some important updates.

<p>There's an article about GConf at <a
href="http://developer.gnome.org/feature/archive/gconf/gconf.html">http://developer.gnome.org/feature/archive/gconf/gconf.html</a>.

<h2>Download</h2>

<p>Find the latest GConf at <a href="ftp://ftp.gnome.org/pub/GNOME/sources/GConf/1.2/">ftp://ftp.gnome.org/pub/GNOME/sources/GConf/1.2/</a>.

<h2>What's cool about GConf?</h2>

<p>The root motivation for GConf is to make application preferences
more manageable for system administrators. The initial GConf
implementation has some shortcomings in this area; however, the
client-side API should be correct, and the initial implementation is a
decent first cut. See the "Future Directions" section for some ways we
might improve it. We should be able to enhance the implementation
without having to modify applications.

<p>Another important motivation for GConf is that it's "process
transparent." This means that if I change a setting from one
application, it instantly updates in all other applications that are
interested in that setting. This technology is vital for the snazzy
"instant apply" UI of GNOME 2, and vital for writing applications made 
up of multiple out-of-process components.

<p>The article at <a
href="http://developer.gnome.org/feature/archive/gconf/gconf.html">http://developer.gnome.org/feature/archive/gconf/gconf.html</a>
goes into some more detail on some of this.

<h2>Introduction to GConf</h2>

<p>Here are some quick-and-easy docs with some key points everyone
should know.

<p>GConf involves a few new concepts, but no rocket science.
Essentially GConf provides a preferences database, which is like a
simple filesystem. The filesystem contains <i>keys</i> organized into
a hierarchy. Each key is either a directory containing more keys, or
has a value. For example, the key
<tt>/apps/metacity/general/titlebar_font</tt> contains an integer
value giving the size of the titlebar font for the Metacity window
manager.

<p>GConf comes with a command line tool called <tt>gconftool-1</tt> 
(for version 1) or <tt>gconftool-2</tt> (for version 2) that you can 
use to get an idea what's going on. Try this command:
<pre>
    $ gconftool-2 -R /desktop/gnome
</pre>
That will display some of the GNOME 2 desktop settings if you've 
installed GNOME 2.

<h3>Configuration Sources</h3>

<p>GConf looks for each value in a series of storage locations called
<i>configuration sources</i>.  These are specified in a file called
<tt>/etc/gconf/&lt;version&gt;/path</tt>. Each configuration source
has a backend that knows how to read it - for now, this is always 
the "xml" backend, which stores data in XML files.

<p>By default, GConf comes configured as follows:
<pre>
   xml:readonly:/etc/gconf/gconf.xml.mandatory
   include "$(HOME)/.gconf.path"
   xml:readwrite:$(HOME)/.gconf
   xml:readonly:/etc/gconf/gconf.xml.defaults
</pre>

<p>If a value is set in the first source, which is read only, 
then users can't delete that value, and thus can't set 
a value of their own. These settings become <em>mandatory</em>
for all users.

<p>The "include" line allows users to insert their own 
configuration sources into the search path by creating a 
file in their home directory called <tt>.gconf.path</tt>.

<p>The readwrite source <tt>~/.gconf</tt> is where user settings 
are normally written.

<p>The last source is where schemas are usually stored - see the next
section. A different default schema source can be specified by
creating the file <tt>/etc/gconf/schema-install-source</tt>; this file
changes the return value of <tt>gconftool-2 --get-default-source</tt>,
which causes applications and RPM/deb packages to install schemas 
to the new source.

<p>In addition to <tt>$(HOME)</tt>, the variable <tt>$(USER)</tt> 
can be used, and any variable <tt>$(ENV_FOO)</tt> will be replaced 
by the value of the environment variable <tt>FOO</tt>. So 
<tt>$(ENV_DISPLAY)</tt> might be handy, for example.

<h3>Schemas</h3>
<p>Keys normally have simple values such as integers, strings, 
or lists of those. However, a special kind of value called a 
<i>schema</i> can also be stored in GConf.

<p>A schema is a bundle of metainformation describing a configuration
setting. This metainformation includes the type of value, short
documentation on the setting, and the factory default for that value.
Schemas are conventionally stored in the database under the
<tt>/schemas</tt> toplevel directory.

<p>For example:
<pre>
    $ gconftool-2 --get /schemas/apps/metacity/general/num_workspaces
    Type: int
    List Type: *invalid*
    Car Type: *invalid*
    Cdr Type: *invalid*
    Default Value: 4
    Owner: metacity
    Short Desc: Number of workspaces
    Long Desc: 
              Number of workspaces. Must be more than zero, and 
              has a fixed maximum (to prevent accidentally destroying 
              your desktop by asking for 34 million workspaces).
</pre>

If the "Type:" field is "list", then the "List Type:" field will be
"integer" or the like indicating that the list is a list of integers.
Similarly, if the "Type:" field is "pair", then types of the first and
second members of the pair are given as "Car Type:" and "Cdr Type:"
(the names are an odd Lisp inheritance).

<p>Note the "Default Value:" and documentation fields.

<p>Keys can have a schema name associated with them. For example, the
above schema name is associated with the key
<tt>/apps/metacity/general/num_workspaces</tt>; you can check this
with gconftool:
<pre>
    $ gconftool-2 --get-schema-name /apps/metacity/general/num_workspaces
    /schemas/apps/metacity/general/num_workspaces
</pre>

<p>Note that by convention, the schema for a key is obtained by
prefixing the key with <tt>/schemas/</tt> - but this is only a
convention. The convention can't be followed when multiple keys need
to share the same schema, which happens from time to time.

<p>When a key's value has not been set by the user, GConf will fall
back to the factory default in the key's schema. So 
if <tt>/apps/metacity/general/num_workspaces</tt> has not been set, the 
default value of "4" would be used.

<h3>Schema files</h3>
<p>Application developers create files called <i>schema files</i>, 
traditionally ending in the <tt>.schemas</tt> extension.
These are in a nice human-readable format.

<p>These files are not used by GConf directly. Instead, 
when you "make install" or install an RPM/deb package, 
gconftool can be invoked to take the schemas in the
schema file for an application and install them 
into one of the configuration sources. The schema install 
process also associates schema names with keys, so 
GConf can find the right schema for a given key.

<p>Conventionally, schema files are also placed in
<tt>/etc/gconf/schemas/</tt>; this is primarily for the convenience of
system administrators, who can use these files to initialize a
newly-created configuration source. If the schema files weren't
installed, then creating a new configuration source would require
reinstalling all applications.

<p>Applications and RPM/deb packages install to the config source
returned by <tt>gconftool-2 --get-default-source</tt>; this source can
be overridden by placing a different source address in the file
<tt>/etc/gconf/schema-install-source</tt>.

<h3>GConf per-user daemon (gconfd)</h3>

<p>The current GConf implementation involves a per-user daemon.  This
daemon's primary purpose is to notify applications when a
configuration value has changed. As a secondary task, it caches 
values, so each application doesn't have to parse XML files.

<p>The daemon normally exits a couple of minutes after the last 
application using it has exited.

<h3>Application developer information</h3>

<p>Be sure to read the key naming conventions in the reference
manual. In particular, your application should place its preferences
under a <tt>/apps/myappname</tt> directory, and keys should be named
in all lowercase with underscores separating words.

<p>Avoid placing values directly below
<tt>/apps/myappname</tt>. Instead, create subdirectories that divide
up the values into logical groups. This will make GConf internals more
efficient, and will also allow you to listen for changes with finer
granularity.

<p>Always use a model-view architecture with GConf; i.e. don't 
change the state of your application except in response to 
preference change notifies.

<p>Do not store anything but preferences in GConf. Documents, session
state, random data blobs do not belong in GConf.  Stuff breaks if you
do this. Moreover, <i>THERE IS NO GUARANTEE THAT IT'S EVEN POSSIBLE TO
WRITE TO THE GCONF DATABASE</i>. Which means you <i>may not</i> use
GConf as an IPC mechanism or when it's <i>required</i> to be able to
store a piece of data.

<p>Use GConfClient, not GConfEngine directly.

<p>Your application should not allow the user to change any key for
which gconf_client_key_is_writable() returns FALSE.  If you're feeling
elaborate, you can recheck this flag anytime you receive a notify
(call gconf_entry_get_is_writable() on the entry in the notification).

<p>To test that you're handling non-writable keys correctly, 
edit <tt>/etc/gconf/1/path</tt> or <tt>/etc/gconf/2/path</tt>
and comment out the line with the "readwrite" storage location, 
then use <tt>gconftool-2 --shutdown</tt> to restart gconfd, 
then restart your app and see how it works.

<p>Values received from GConf are <i>UNTRUSTED</i>, just as if they
came from a file on disk. You need to check the validity of incoming
values, including the value type. Use <tt>gconftool --break-key</tt>
to verify that your application is robust. When you get an invalid
value, the right thing to do is usually nothing; just keep the value
you were using prior to notification of the new one.

<p>As a rule of thumb, <i>NEVER</i> modify a GConf key in response to
receiving a notification from GConf. This is a recipe for infinite
loops and generally indicates a conceptual/design problem as well.

<p>To install schemas, your <tt>Makefile.am</tt> should have something
like:
<pre>
    schemadir   = @GCONF_SCHEMA_FILE_DIR@
    schema_DATA = metacity.schemas

    install-data-local:
	    GCONF_CONFIG_SOURCE=$(GCONF_SCHEMA_CONFIG_SOURCE) $(GCONFTOOL) --makefile-install-rule $(srcdir)/$(schema_DATA)
</pre>
For those <tt>Makefile.am</tt> rules, you need <tt>AM_GCONF_SOURCE_2</tt>
in your <tt>configure.in</tt>.

<p>RPM/deb packages should disable schema installation during 
the "make install" phase, as follows:
<pre>
    export GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1
    make install
    unset GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL
</pre>
And then in the post-install script, run something like:
<pre>
    export GCONF_CONFIG_SOURCE=`gconftool-2 --get-default-source`
    gconftool-2 --makefile-install-rule %{_sysconfdir}/gconf/schemas/metacity.schemas &gt; /dev/null
</pre>

<h3>Conventional value formats</h3>
<p>Some kinds of value have conventional representations in the 
GConf database. <tt>gconf-editor</tt> will eventually have special 
knowledge of these formats.

<p>
<ul>
<li><b>Colors</b> should be stored as an HTML-style color 
specification, e.g. "#FFFFFF"

<li><b>Enumerations</b> should be stored as <i>strings</i>; DO NOT
store them as integers, because it's incredibly fragile and
error-prone, not to mention cryptic for users of <tt>gconftool</tt> or
<tt>gconf-editor</tt>. You can use the <tt>gconf_enum_to_string()</tt> 
convenience function for this.

<li><b>Keybindings</b> for a GTK+ application should be 
in a subdirectory called "keybindings" where each key in the 
directory is one keybinding. The keys are strings, and have the value 
"disabled" or a value that <tt>gtk_accelerator_parse()</tt> 
can understand.
</ul>

<h3>Backward/forward compatibility</h3>

<p>Here are the base rules:
<ul>
<li>Config keys must be backward AND FORWARD compatible
<li>What this means is that if I log in from two places,
    using two versions of an application, with the same gconf
    database, then nothing should break.
<li>To allow applications to add new features, we do allow that if you
    are logged in using two versions, you may need to configure
    "the same" thing twice, once per version.
    Of course it's best to avoid this.
</ul>

<p>To implement the rules:
<ul>
<li>If you in any way change the set of possible values
    of a config key, or how those values are
    interpreted, you must rename the config key.
<li>If you don't rename the config key you can't add
    new possible values. The main case in which
    this will be painful is for "enum" config keys,
    where you add a new enum value in the code
    and have to change the schemas accordingly.
</ul>

<p>If you rename a config key due to a change in possible values, you
could have your app copy the old key to the new key on startup, for
the case where the new key is unset. However it would be wrong to
delete the old key here (because the user may still use old versions
of the app simultaneously). You should only create the new key.

<p>The reason why you need to be backward compatible is so that users
don't lose their settings when they upgrade the application
version. The reason why you need to be forward compatible is that many
times users share the same home directory for many different computers
running different OS versions or even different operating systems
entirely.

<h2>gconf-editor</h2>

<p>GNOME has a prototype-quality unfinished program called 
<tt>gconf-editor</tt> which is sort of the GUI equivalent of 
<tt>gconftool</tt>. Try it out.

<h2>FAQ/Troubleshooting</h2>

<p>This section assumes the background information in the Introduction
to GConf section above.

<h3>How do I use GConf 1 and 2 at the same time?</h3>

<p>Things should just work - GConf 1 apps can talk to the GConf 2
daemon, and vice versa.

<p>The tricky part is if you install GConf 1 and 2 to different
prefixes.  This means that by default they will use different sources
to find schemas. You can fix this in several ways; one is to install
the schemas for each application to both source locations, another is
to edit <tt>prefix/etc/gconf/2/path</tt> to point at the same sources
as <tt>prefix/etc/gconf/1/path</tt> and then create a file
<tt>prefix/etc/gconf/schema-install-source</tt> containing the 
address of the source where you want newly-installed applications
to install their schemas.

<h3>I'm having a lock file problem. What do I do?</h3>

<p>Usually a problem here involves either NFS, or a kernel bug.

<p>The per-user daemon locks two files in the default configuration:
<pre>
   ~/.gconfd/lock/ior
   ~/.gconf/%gconf-xml-backend.lock/ior
</pre>
The first lock is to ensure that only one gconfd is running. 
The second lock is to ensure only one program accesses the 
XML config source at a time.

<p>If you have an NFS-mounted home directory, you must be running 
an rpc.statd/rpc.lockd setup on both NFS client and NFS server, 
so that file locking works. On Red Hat Linux, this means the 
"nfslock" service must be running. Enable it permanently with 
the <tt>chkconfig</tt> tool - see its manual page. Turn it on 
or off at any given time with <tt>service nfslock start</tt> or 
<tt>service nfslock stop</tt>. You must be root to do this.

<p>If the kernel crashes (or the power cord gets pulled) on an NFS client
machine, theoretically when you reboot the client machine it will notify the NFS
server that it has rebooted and all previously-held locks should be
released. However, many operating systems including Red Hat Linux 7.2 do not
properly do this; so you will have stale locks after a crash. If no gconfd is
running, these locks may safely be removed. If gconfd is running though, <i>DO
NOT</i> remove them; if you have two gconfd processes for a single user, bad
things may happen to that user's preferences once in a while.

<p>See also the next question.

<h3>Can I bypass the lockfile stuff?</h3>

<p>Red Hat Linux 8.0 contains an experimental patch that allows you to set the
environment variable "GCONF_LOCAL_LOCKS=1" - do this in a script in
/etc/profile.d for example. Then locks will be kept in /tmp. This has two
important caveats. First, there is a security flaw where users can keep each
other from logging in by creating someone else's lock file. YOU SHOULD NOT
ENABLE GCONF_LOCAL_LOCKS IF THIS IS A PROBLEM FOR YOUR SITE. However, it's
"only" a denial of service attack, and the user would have to leave the
problem-causing file owned by themselves, so you could track them down and get
angry. Second, preferences notification won't work between machines; you will
get "last machine to write preferences wins" behavior instead of "state is
shared" behavior. You can probably live with that.

<p>This patch will probably be in GNOME 2.2, ideally with the denial-of-service
issue fixed.

<h3>How do I log in from two machines at once?</h3>

<p>You can only have one gconfd accessing a given 
configuration source at the same time. This means you need to 
share the same gconfd between the two machines.

<p>This Just Works, with two common catches:
<ul>
<li>You have a firewall between the machines.
<li>For security reasons, remote CORBA connections 
    are normally disabled by default.
</ul>

<p>To enable remote CORBA connections, add the line 
"ORBIIOPIPv4=1" to <tt>/etc/orbitrc</tt> and then restart 
gconfd using <tt>gconftool-2 --shutdown</tt>.

<h3>How can I see log messages from gconfd?</h3>
<p>If you're having gconf problems, the first step is 
to see if gconfd is printing error messages. 
To do this, you need to look at the <tt>user.*</tt> level of syslog. 
Red Hat Linux has this level of logging turned off by default,
other systems have it enabled. If you don't have it by default, 
add a line like this to <tt>/etc/syslog.conf</tt>:
<pre>
 user.* /var/log/user
</pre>
Then run a command such as <tt>service syslog restart</tt> 
to reload the config file. At that point <tt>/var/log/user</tt> 
will begin to log gconfd messages.

<p>To put gconfd in hugely verbose mode, you can send it the 
<tt>USR1</tt> signal with <tt>kill -USR1 &lt;process-id&gt;</tt> 
or <tt>killall -USR1 gconfd-2</tt>. Send USR1 a second time to 
toggle huge verbosity back off. Note that GConf will get 
really, really slow when in verbose mode; syslog is not 
efficient.

<h3>How can I turn off log messages from gconfd?</h3>

<p>Change where <tt>user.*</tt> messages end up.
Syslog unfortunately does not let you redirect messages 
according to which daemon sends them, but very little other
than gconfd uses <tt>user.*</tt>.

<h3>gconfd keeps me from unmounting my home directory, how 
can I get it to exit?</h3>

<p>It should exit a couple of minutes after the last application 
using GConf has exited. You could put a "gconftool --shutdown" 
in your .logout script or the like, if you want it to exit sooner.

<p>GConf should really be enhanced in the future to exit immediately
when all apps using it have exited. This can only be done in GConf 2
since ORBit 2 has the required features. Patches are welcome, 
otherwise I'll get to it eventually.


<h3>What are some tools for debugging/profiling gconf or apps that use
it?</h3>

<p>One handy trick is to set the <tt>GCONF_DEBUG_TRACE_CLIENT</tt>
environment variable when running a GConf client application.
This will give copious debug output about what that client 
is doing.

<h3>Some other weird thing is wrong with my gconf!!!</h3>

<p>Try shutting down gconfd (<tt>gconftool-2 --shutdown</tt>) and
running the <tt>gconf-sanity-check-1</tt> or
<tt>gconf-sanity-check-2</tt> applications - these will tell you about
common problems.  Also, be sure you have the latest GConf version.

<p>If you can't figure out what's going on, mail
<tt>gconf-list@gnome.org</tt> with the following information:
<ul>
<li>Exact error messages from any applications.
<li>Exact version of GConf 1 and GConf 2 that you have installed.
<li>Output of <tt>ps jaxwww | grep gconf</tt>.
<li>Output of <tt>gconf-sanity-check-1</tt> or <tt>gconf-sanity-check-2</tt> if any.
<li>What operating system are you using, and what version of it.
<li>What appears in the <tt>user.*</tt> syslog (see above 
    for how to turn on <tt>user.*</tt> syslog). 
</ul>

<p>Before you mail, please read this whole web page.

<h3>Where do I report bugs or make suggestions?</h3>
<p>Go to <a
href="http://bugzilla.gnome.org">http://bugzilla.gnome.org</a> and
enter a new bug, or run the GNOME "bug-buddy" application.

<p>DO NOT put support requests in bugzilla; mail gconf-list 
as noted in the previous question.

<h2>Future Directions</h2>

<p>Some things I'd like to see in GConf, though I don't know 
currently who will implement them (or when):

<ul>
<li>A network server backend - based on http, <a
href="http://asg.web.cmu.edu/acap/">ACAP</a>, LDAP, a custom protocol,
or whatever, is really required for environments where 
CORBA connections between machines and NFS/AFS mounts aren't 
adequate.

<li>Rethink the CORBA/gconfd implementation strategy; perhaps 
using a generic message bus, or a custom low-latency protocol.
Very vague ideas so far.

<li>Rethink the client API to be more convenient for application
developers.

<li>Add support for transactions (the API for this exists 
in the form of GConfChangeSet, but committing a change set is 
not currently atomic).

<li>Enhance tools such as gconftool and gconf-editor.

<li>Enhance format of schema files to support intltool 
for translating docs and default values.

<li>Rethink how logins from more than one machine are handled, so we
can avoid a single daemon shared among machines, thus avoiding the
file locking in home directories and dodging all the NFS issues and so
on.

</ul>

</body>
</html>


