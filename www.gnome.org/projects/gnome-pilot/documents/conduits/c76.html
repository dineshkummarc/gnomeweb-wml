<HTML
><HEAD
><TITLE
>Conduit methods</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.44"><LINK
REL="HOME"
TITLE="Gnome pilot conduits"
HREF="gnome-pilot-conduit-design.html"><LINK
REL="PREVIOUS"
TITLE="Beginning conduit implemention"
HREF="x61.html"><LINK
REL="NEXT"
TITLE="Conduit control-center applet"
HREF="conduit-capplet.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Gnome pilot conduits</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x61.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="conduit-capplet.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="AEN76"
>Chapter 2. Conduit methods</A
></H1
><P
>This chapter deals with methods your conduit should/must
support. At the time of writing, the code examples are untested,
meaning they have not been compiled. Comments are welcome.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SO-REQUIREMENTS"
>Minimal requirements</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN81"
>Required methods of the conduit</A
></H2
><P
>Conduits are stored in .so file, and are opened by the
	conduit manager using <TT
CLASS="FUNCTION"
>dlopen</TT
>. The
	following two methods <I
CLASS="EMPHASIS"
>must</I
> be present in
	the .so file.</P
><P
></P
><UL
><LI
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>GnomePilotConduit* <B
CLASS="FSFUNC"
>conduit_get_gpilot_conduit</B
></CODE
>(guint32<VAR
CLASS="PDPARAM"
>pilotId</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This method shall initialize the returned
		  GnomePilotConduit structure.</P
><P
>The
		  structure must be aware of the paramater
		  <TT
CLASS="PARAMETER"
><I
>pilotId</I
></TT
>.  Any configurations
		  read or written must be for this id.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>pilotId</I
></TT
></DT
><DD
><P
>The Id number of the pilot for which the
			conduit is being instantiated.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>A newly instantiated conduit or NULL if failure.</P
></DD
></DL
><P
>A suggested method is having a gnomeconfig file,
            named after the conduit, and inside this file have a
            section for each pilotid.</P
><P
>The return type determines your conduit type. If you
            return a <SPAN
CLASS="TYPE"
>GnomePilotConduitStandard</SPAN
> pointer,
            the conduit is a custom conduit, whereas a
            <SPAN
CLASS="TYPE"
>GnomePilotConduitStandardAbs</SPAN
> is a SyncAbs
            conduit.</P
><P
>Since the return type of
            <TT
CLASS="FUNCTION"
>conduit_get_gpilot_conduit</TT
> is simply
            <SPAN
CLASS="TYPE"
>GnomePilotConduit</SPAN
>, you can implement your own
            type inheriting from the given types. The conduit classes
            are implemented using the GtkObject system, see <A
HREF="http://developer.gnome.org/arch/gtk/object.html"
TARGET="_top"
>GTK+ Object System</A
>.</P
><P
>At the beginning of
            <TT
CLASS="FUNCTION"
>conduit_get_gpilot_conduit</TT
>, you'll
            want to call the appropriate new method,
            eg. <TT
CLASS="FUNCTION"
>gnome_pilot_conduit_standard_abs_new</TT
>
            for creating a SyncAbs object.</P
><P
>This is an example that creates a SyncAbs
	    conduit. This example will be reused later in this
	    document, where more code will be added</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>GnomePilotConduit *
conduit_get_gpilotd_conduit( guint32 pilotId) 
{ 
        GnomePilotConduitStandardAbs *retval;
    
        /* create a new conduit for the pilots database called
           MemoDB, which has a creator id of 0x6d656d6f */
        retval = gnome_pilot_conduit_standard_abs_new("MemoDB",0x6d656d6f);
     
        /* load configuration, see later */
        /* set conduit data, see later */
        /* connect signals, see later */  

        return GNOME_PILOT_CONDUIT(retval);
}
 </PRE
></TD
></TR
></TABLE
></LI
><LI
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>conduit_destroy_gpilot_conduit</B
></CODE
>(GnomePilotConduit* <VAR
CLASS="PDPARAM"
>conduit</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This method shall free all dynamically
		  allocated memory. The paramter
		  <TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
> points the structure
		  returned by the conduits own
		  <TT
CLASS="FUNCTION"
>conduit_get_gpilot_conduit</TT
>
		  method. After this method is called, the conduit
		  will not be used again.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>The conduit structure returned from
			<TT
CLASS="FUNCTION"
>conduit_get_gpilot_conduit</TT
>.</P
></DD
></DL
></DD
></DL
><P
>Again, an example.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void
conduit_destroy_gpilotd_conduit( GnomePilotConduit *conduit ) 
{ 
        /* delete any conduit data, such as config etc */
        gtk_object_destroy(conduit);
}</PRE
></TD
></TR
></TABLE
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN153"
>Conduit signals</A
></H2
><P
>The conduit objects all have to respond to certain
        signals. Which signals depend on the conduit. In this section,
        all conduit signals are explained.</P
><P
>Implementing the conduit methods is done in the usual
matter of connecting signals in the GtkObject system, see <A
HREF="http://developer.gnome.org/arch/gtk/object.html"
TARGET="_top"
>GTK+ Object
System</A
>.</P
><P
>Here is the continued example, for creating a
SyncAbonduit, and connecting to the "match_record" signal c</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;/* a skeleton match_record. The initial g_return_val_if_fail
   checks the parameters are correct. */
   
static gint
my_conduit_match_record (GnomePilotConduitStandardAbs *conduit,
                         LocalRecord **local,
                         PilotRecord *remote,
                         gpointer data)
{
        g_return_val_if_fail(local!=NULL,0);
        g_return_val_if_fail(remote!=NULL,0);

        ... find a local record
        ... if none return -1
        ... else allocate and fill local.

        return 0;
}

static gpointer
load_my_conduit_data(...)
{
   ... returns a pointer containing the data your conduit
   needs, eg. GLists with records etc.
  
   return NULL;
}

GnomePilotConduit *
conduit_get_gpilotd_conduit( guint32 pilotId) 
{ 
        GnomePilotConduitStandardAbs *retval;
        gpointer my_conduit_data;   
 
        /* create a new conduit for the pilots database called
           MemoDB, which has a creator id of 0x6d656d6f */
        retval = gnome_pilot_conduit_standard_abs_new("MemoDB",0x6d656d6f);
     
        /* load configuration, see later */

        my_conduit_data = load_my_conduit_data(...);
        gtk_signal_connect(retval,"match_record",
                           (GtkSignalFunc)my_conduit_match_record,
                           my_conduit_data);
        /* gtk_signal_connect for the rest of the signals */

        return GNOME_PILOT_CONDUIT(retval);
}</PRE
></TD
></TR
></TABLE
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SIGNAL-CONDUIT-FILE"
>Signals for file conduits</A
></H3
><P
>*** This will contain a description of signals for file conduits</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SIGNAL-CONDUIT-BACKUP"
>Signals for backup conduits</A
></H3
><P
>*** This will contain a description of signals for backup conduits</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SIGNAL-CONDUIT-STANDARD"
>Signals for custom conduits</A
></H3
><P
>A conduit must support <I
CLASS="EMPHASIS"
>at least</I
>
	  one of the following signals. It may choose to support more
	  or all, in which case the user gets to choose which is used
	  during synchronization, using the conduits control-center
	  applet (see <A
HREF="conduit-capplet.html"
>Chapter 3</A
>).</P
><P
>These methods, in addition to
	  <TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
> take an additional parameter
	  <SPAN
CLASS="TYPE"
>GPilotDBInfo*</SPAN
> <TT
CLASS="PARAMETER"
><I
>dbi</I
></TT
>, a
	  pointer to a structure containing eg. a socket handle for
	  communicating with the pilot.</P
><P
></P
><OL
TYPE="1"
><LI
><A
NAME="CUSTOM-CONDUIT-SYNCHRONIZE"
></A
><P
>Signal <TT
CLASS="FUNCTION"
>"synchronize"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>gint<B
CLASS="FSFUNC"
>(*synchronize)</B
></CODE
>(GnomePilotConduitStandard* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, GnomePilotDBInfo* <VAR
CLASS="PDPARAM"
>dbi</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This method implements synchronization,
		    where the conduit does record-level
		    synchronization of updates new records between the
		    two devices, see <I
CLASS="CITETITLE"
>POSC</I
> for
		    more on this.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>The conduits <B
CLASS="KEYCAP"
>this</B
>
			  pointer, the conduit structure returned from
			  <TT
CLASS="FUNCTION"
>conduit_get_gpilot_conduit</TT
>.</P
></DD
></DL
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>dbi</I
></TT
></DT
><DD
><P
>Structure containing
			  <SPAN
CLASS="PRODUCTNAME"
>pilot-link</SPAN
>
			  connection info and other. Found in the
			  <TT
CLASS="FILENAME"
>gnome-pilot-dbinfo.h</TT
>
			  header file.</P
></DD
></DL
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>user_data</I
></TT
></DT
><DD
><P
>The pointer given as the last
			  parameter to the
			  <TT
CLASS="FUNCTION"
>gtk_signal_new</TT
> for the
			  callback.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>Returns 0 for success, a negative value for
		    failure.</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"copy_from_pilot"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>gint<B
CLASS="FSFUNC"
>(*copy_from_pilot)</B
></CODE
>(GnomePilotConduitStandard* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, GnomePilotDBInfo* <VAR
CLASS="PDPARAM"
>dbi</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This method will delete all local records
		    and store all records from the pilot in the local
		    system.</P
></DD
><DT
>Parameters</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
><DT
>Returns</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"copy_to_pilot"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>gint<B
CLASS="FSFUNC"
>(*copy_to_pilot)</B
></CODE
>(GnomePilotConduitStandard* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, GnomePilotDBInfo* <VAR
CLASS="PDPARAM"
>dbi</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This method will delete all records in the
		    pilot, and write all the local records to the
		    pilot.</P
></DD
><DT
>Parameters</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
><DT
>Returns</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"merge_to_pilot"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>gint<B
CLASS="FSFUNC"
>(*merge_to_pilot)</B
></CODE
>(GnomePilotConduitStandard* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, GnomePilotDBInfo* <VAR
CLASS="PDPARAM"
>dbi</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Merges new data on the local system into the
		    pilot by adding new records to the pilot.</P
></DD
><DT
>Parameters</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
><DT
>Returns</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"merge_from_pilot"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>gint<B
CLASS="FSFUNC"
>(*merge_from_pilot)</B
></CODE
>(GnomePilotConduitStandard* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, GnomePilotDBInfo* <VAR
CLASS="PDPARAM"
>dbi</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Merges new data on the pilot onto local
		    system by adding new records to the local
		    system.</P
></DD
><DT
>Parameters</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
><DT
>Returns</DT
><DD
><P
>See <A
HREF="c76.html#CUSTOM-CONDUIT-SYNCHRONIZE"
>1</A
></P
></DD
></DL
></LI
></OL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SIGNAL-CONDUIT-SYNCABS"
>Signals for SyncAbs conduits</A
></H3
><P
>This a a walkthrough of <SPAN
CLASS="ACRONYM"
>SyncAbs</SPAN
>'s
	  seventeen methods. Their purpose, importance, usage by the foru
	  synchronization process (Fast/Slow sync, copy to/from
	  remote) and how the should behave.</P
><P
>These use normal UNIX api return values, meaning 0 on
	  success, negative values on failure. However, the iteration
	  methods differ, in that they return 0 on completed iteration
	  and 1 on successfull iteration step. Other methods are also
	  required to do other parameter changes depending on their
	  success.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"match_record"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*MatchRecord)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord** <VAR
CLASS="PDPARAM"
>local</VAR
>, PilotRecord* <VAR
CLASS="PDPARAM"
>remote</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This method takes the
		    <TT
CLASS="PARAMETER"
><I
>remote</I
></TT
> record, and locates
		    the local record which is supposed to be the same
		    as the remote. The contents on *local belongs to
		    the
		    <SPAN
CLASS="ACRONYM"
>GnomePilotConduitStandardAbs</SPAN
>
		    structure, and is not tampered with by the calling
		    method, so you may freely return a pointer to a
		    local static variable.</P
><P
>The memory
		    allocated by <TT
CLASS="FUNCTION"
>MatchRecord</TT
> is
		    freed by the caller by a call to
		    <TT
CLASS="FUNCTION"
>FreeMatch</TT
>.</P
><P
>If a call to
		    <TT
CLASS="FUNCTION"
>MatchRecord</TT
> is successfull,
		    it <I
CLASS="EMPHASIS"
>will not be called before</I
>
		    a call to <TT
CLASS="FUNCTION"
>FreeMatch</TT
>, so if
		    needed, you can use static variables.</P
></DD
><DT
>Parameters</DT
><DD
><P
><TT
CLASS="PARAMETER"
><I
>local</I
></TT
> is a pointer to a
		  pointer for storing the record. If no local record
		  matching the remote is found, set
		  *<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> to NULL.</P
><P
>Only one local record should match a remote
		  record.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, a negative value for
		  failure. And on success, sets
		  *<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> to the appropriate
		  record.</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync and SlowSync.</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"free_match"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*FreeMatch)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord** <VAR
CLASS="PDPARAM"
>local</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This method is responsible for freeing memory
		  allocated by
		  <TT
CLASS="FUNCTION"
>MatchRecord</TT
>.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>local</DT
><DD
><P
> pointer to pointer to record. This
			records resources should be freed, and
			*<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> set to
			NULL.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"archive_local"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*ArchiveLocal)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>When a record is marked as archived on the
		  pilot, this method is called for the corresponding
		  (if any) local record. The method should move this
		  archived record from to local database to a backup
		  "place". If you think in terms of the pilots
		  categories, you would eg. move an archived address
		  to a category called "Archive".</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>local</DT
><DD
><P
>pointer to local record to archive.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"archive_remote"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*ArchiveRemote)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, PilotRecord* <VAR
CLASS="PDPARAM"
>remote</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Unknown</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"store_remote"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*StoreRemote)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, PilotRecord* <VAR
CLASS="PDPARAM"
>remote</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Stores a remote record in the local
		  database/files/whatever.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>remote</DT
><DD
><P
> pointer to a pilots record that is to
			be stored. The method should copy all the
			information needed, and either immediately
			store the record, or queue it for
			storage.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"clear_status_archive_local"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*ClearStatusArchiveLocal)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Unknown</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"iterate"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*Iterate)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* *<VAR
CLASS="PDPARAM"
>local</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Iterates over all the local records.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>local</DT
><DD
><P
>the iterations "pointer". At first call,
			*<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> is NULL. The
			method should then set
			<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> to point at the
			first local record (if none, set to NULL and
			return -1). Upon proceeding calls, move
			<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> to the next
			record, if you reach the end, set
			<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> to NULL and
			return -1.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>1 on success and
		    *<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> is set to non NULL,
		    0 on completion and *<TT
CLASS="PARAMETER"
><I
>local</I
></TT
>
		    is set to NULL, negative value on error.</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"iterate_specific"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*IterateSpecific)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord** <VAR
CLASS="PDPARAM"
>local</VAR
>, int <VAR
CLASS="PDPARAM"
>flag</VAR
>, int <VAR
CLASS="PDPARAM"
>archived</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Iterates over records that statisfy the criteria.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>local</DT
><DD
><P
>Same as in <TT
CLASS="FUNCTION"
>Iterate</TT
>.</P
></DD
><DT
>flag</DT
><DD
><P
>the records iterated over must have
			the same attribute as
			<TT
CLASS="PARAMETER"
><I
>flag.</I
></TT
></P
></DD
><DT
>archived</DT
><DD
><P
>if positive, the records iterated over
			must be marked as archived.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>1 on success and
		    *<TT
CLASS="PARAMETER"
><I
>local</I
></TT
> is set to non NULL,
		    0 on completion and *<TT
CLASS="PARAMETER"
><I
>local</I
></TT
>
		    is set to NULL, negative value on error.</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"purge"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*Purge)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Purges the local base - all records marked
		  Delete are deleted and all records marked Archived
		  are archived.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote.</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"set_status"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*SetStatus)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, int<VAR
CLASS="PDPARAM"
>status</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Sets the status of a local record</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>local</I
></TT
></DT
><DD
><P
>the local record</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>status</I
></TT
></DT
><DD
><P
>The new status for the record</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"set_archived"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*SetArchived)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, int<VAR
CLASS="PDPARAM"
>archived</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Unknown</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>""</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>guint32  <B
CLASS="FSFUNC"
>(*GetPilotID)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Retrieves the pilot-record-number for the
		  given local record. The returned number should be a
		  record id that matches a record on the pilot, which
		  should be "the same" as the local.
		  </P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>local</DT
><DD
><P
>A <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
>* pointing to
			a local record.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>A <SPAN
CLASS="TYPE"
>guint32</SPAN
>, containing the
		  record id (unsigned 32 bit integer).</P
></DD
><DT
>Needed by</DT
><DD
><P
>?</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"set_pilot_id"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*SetPilotID)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, guint32 <VAR
CLASS="PDPARAM"
>ID</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Associates a local record with a pilot
		    record. This is called during synchronization,
		    when a new record is found in the local base. The
		    record is added to the pilot, which assigns a id
		    to the record. This id is then passed on to the
		    conduit via this call.</P
><P
>This id is
		    also used when iterating over records, where a
		    modification to a local record requires a lookup
		    in the pilot. This lookup is done using this Id,
		    so it is important to save it in the local
		    database.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>local</DT
><DD
><P
>A <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
>* pointing to
			the record to which the id was
			assigned. </P
></DD
><DT
>ID</DT
><DD
><P
>A <SPAN
CLASS="TYPE"
>guint32</SPAN
> integer
			containg the id.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"compare"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*Compare)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>Local</VAR
>, PilotRecord* <VAR
CLASS="PDPARAM"
>remote</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Compares a local record with a pilot record,
		  used during synchronization. If both the local the
		  pilot record has been modfied, this is called to
		  determine if the changes are identical.</P
><P
>Typical, a conduit will compare the contents
		  of an decoded record in some way, but excatly how,
		  is up to the conduit.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>Local</DT
><DD
><P
>Pointer to the local record</P
></DD
><DT
>remote</DT
><DD
><P
>Pointer to the pilots record</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 if identical in whatever way the conduit
		  decides, positive if different, negative if failure.</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync.</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"compare_backup"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*CompareBackup)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>Local</VAR
>, PilotRecord* <VAR
CLASS="PDPARAM"
>remote</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Unknown</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote, Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"free_transmit"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*FreeTransmit)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>Local</VAR
>, PilotRecord* <VAR
CLASS="PDPARAM"
>remote</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Free memory allocated by a call to
		  <TT
CLASS="FUNCTION"
>Transmit</TT
>. Unless
		  <TT
CLASS="FUNCTION"
>Transmit</TT
> returns NULL, this
		  method is called to free all resources allocated to
		  the pilot record. As with
		  <TT
CLASS="FUNCTION"
>MatchRecord</TT
>/<TT
CLASS="FUNCTION"
>FreeMatch</TT
>,
		  the allocation/freeing is pairwise, so after a
		  successfull <TT
CLASS="FUNCTION"
>Transmit</TT
> call,
		  <TT
CLASS="FUNCTION"
>FreeTransmit</TT
> will be called
		  <I
CLASS="EMPHASIS"
>before</I
> another
		  <TT
CLASS="FUNCTION"
>Transmit</TT
> is called.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>Local</DT
><DD
><P
>The local record given as argument to
			<TT
CLASS="FUNCTION"
>Transmit.</TT
></P
></DD
><DT
>Remote</DT
><DD
><P
>The returnvalue from the preceeding
			<TT
CLASS="FUNCTION"
>Transmit</TT
> call.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"delete_all"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>(*DeleteAll)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>Delete all local records. Called eg. when
		  doing a Copy From Remote. All the local records must
		  perish and begone.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error.</P
></DD
><DT
>Needed by</DT
><DD
><P
>Copy From Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"transmit"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>gint  <B
CLASS="FSFUNC"
>(*Transmit)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, LocalRecord* <VAR
CLASS="PDPARAM"
>local</VAR
>, RemoteRecord** <VAR
CLASS="PDPARAM"
>remote</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>From a given local record, create a
		  <SPAN
CLASS="TYPE"
>PilotRecord</SPAN
> record ready for transmit
		  to the pilot.</P
><P
>The memory allocated is
		  freed by the caller, who calls
		  <TT
CLASS="FUNCTION"
>FreeTransmit</TT
>.</P
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>local</DT
><DD
><P
>A non-null <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
>*,
			pointing to a local record returned from
			eg. <TT
CLASS="FUNCTION"
>Iterate</TT
>.</P
></DD
><DT
>remote</DT
><DD
><P
>A pointer to a <SPAN
CLASS="TYPE"
>RemoteRecord</SPAN
>*,
			in which this methods should create a Pilot
                        version of the record.</P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error.</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Copy To Remote</P
></DD
></DL
></LI
><LI
><P
>Signal <TT
CLASS="FUNCTION"
>"pre_sync"</TT
></P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>gint  <B
CLASS="FSFUNC"
>(*PreSync)</B
></CODE
>(GnomePilotConduitStandardAbs* <VAR
CLASS="PDPARAM"
>conduit</VAR
>, GnomePilotDBInfo* <VAR
CLASS="PDPARAM"
>dbinfo</VAR
>, gpointer <VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DL
><DT
>Description</DT
><DD
><P
>This signal is called before the
		    synchronization process begins. In the
		    implementation, the conduit should handle
		    nessecary initialisation, eg. getting the
		    <SPAN
CLASS="TYPE"
>AppInfo</SPAN
> for the database that the
		    conduit is synchronizing.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
>note: calling dlp function will sometime soon be 
		      discouraged.
		    </BLOCKQUOTE
></DIV
></DD
><DT
>Parameters</DT
><DD
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>conduit</I
></TT
></DT
><DD
><P
>pointer to the current
			GnomePilotConduitStandardAbs structure.</P
></DD
><DT
>dbinfo</DT
><DD
><P
>A structure containing info reg. the
			  database opened for the conduit. Check
			  <TT
CLASS="FILENAME"
>gpilotd/gnome-pilot-dbinfo.h</TT
></P
></DD
></DL
></DD
><DT
>Returns</DT
><DD
><P
>0 on success, negative value on error.</P
></DD
><DT
>Needed by</DT
><DD
><P
>FastSync, SlowSync, Merge To Pilot, Merge From Pilot</P
></DD
></DL
></LI
></OL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1149"
>GnomePilotConduitStandardAbs record structures</A
></H2
><P
>This chapter describes how the <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
>
	type for a SyncAbs conduit can be constructed.</P
><P
>Where the type <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
> is used, you'll
	most likely prefer it to contain a bit more then what is
	defined in
	<TT
CLASS="FILENAME"
>gnome-pilot-conduit-standard-abs.h</TT
>. And
	since it is a structure rather then a GtkObject, you cannot
	store data with it using
	<TT
CLASS="FUNCTION"
>gtk_object_set_data</TT
>.</P
><P
>However, since <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
> "objects" only
	leave the conduit from the <TT
CLASS="FUNCTION"
>MatchRecord</TT
>
	call, you can choose one of several approach.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Only use <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
> when dealing with
	    the surrounding system. That means the only times you
	    operate on a <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
> is when you create
	    it in <TT
CLASS="FUNCTION"
>MatchRecord</TT
> and when you
	    receive it in the other calls, where it is used to locate
	    a record of another type.</P
><P
>Matching
	    <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
> "objects" against another object
	    is quite easy, since the id field of a
	    <SPAN
CLASS="TYPE"
>RemoteRecord</SPAN
> is guaranteed to be unique,
	    setting the id field in the returned
	    <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
> in
	    <TT
CLASS="FUNCTION"
>MatchRecord</TT
> will easily allow other
	    calls to find the conduits own record, eg. using
	    hashtables.</P
><P
>Here is an (untested) code example on using
	    hashtables for record storage:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> 
static gint
my_conduit_match_record (GnomePilotConduitStandardAbs *conduit,
                         LocalRecord **local,
                         PilotRecord *remote,
                         GHashTable *my_records)
{
        MyLocalRecord *my_local;

        g_return_val_if_fail(local!=NULL,0);
        g_return_val_if_fail(remote!=NULL,0);

        my_local = g_hash_table_lookup(my_records,G_INT_TO_POINTER(remote-&#62;ID));

        if (my_local == NULL) return -1;

        (*local) = g_new0(LocalRecord,1);
        (*local)-&#62;attr = my_conduit_determine_pilot_attributes(my_local);
        (*local)-&#62;archived = my_conduit_determine_pilot_archive_state(my_local);
        (*local)-&#62;secret = my_conduit_determine_pilot_secret_state(my_local);
        (*local)-&#62;ID = remote-&#62;ID;

        return 0;
}

static gint
my_conduit_set_pilot_id (GnomePilotConduitStandardAbs *conduit,
                         LocalRecord *local,
                         guint32 new_id,
                         GHashTable *my_records)
{
        MyLocalRecord *my_local;

        g_return_val_if_fail(local!=NULL,0);
        g_return_val_if_fail(*local!=NULL,0);

        my_local = g_hash_table_lookup(my_records,G_INT_TO_POINTER((*local)-&#62;ID));

        if (my_local == NULL) return -1;

        my_conduit_set_pilot_id(my_local,new_id);

        /* remove from hashtable */
        g_hash_table_remove(my_records,G_INT_TO_POINTER((*local)-&#62;ID));
        /* reinsert with new id */
        g_hash_table_insert(my_records,my_local,G_INT_TO_POINTER(new_id));

        return 0;
}

GnomePilotConduit *
conduit_get_gpilotd_conduit( guint32 pilotId) 
{ 
        GnomePilotConduitStandardAbs *retval;
        GHashTable *my_records;
 
        /* create a new conduit for the pilots database called
           MemoDB, which has a creator id of 0x6d656d6f */
        retval = gnome_pilot_conduit_standard_abs_new("MemoDB",0x6d656d6f);
     
        /* load configuration, see later */

        my_records = my_conduit_load_records(pilotId);
        gtk_signal_connect(retval,"match_record",
                           (GtkSignalFunc)my_conduit_match_record,
                           my_records);
        gtk_signal_connect(retval,"set_pilot_id",
                           (GtkSignalFunc)my_conduit_set_pilot_id,
                           my_records);
        /* gtk_signal_connect for the rest of the signals */

        return GNOME_PILOT_CONDUIT(retval);
}</PRE
></TD
></TR
></TABLE
><P
>Note that this example may be very inefficient,
	    since it loads all the records at conduit creation. Fine
	    for 42 simple text records, bad for 42000 complex
	    records. You may want to load the record when
	    <TT
CLASS="FUNCTION"
>my_conduit_match_record</TT
> is called,
	    insert into the hashtable and keep there until
	    <TT
CLASS="FUNCTION"
>FreeMatch</TT
> is called.</P
></LI
><LI
><P
>Create a structure <SPAN
CLASS="TYPE"
>MyLocalRecord</SPAN
> to use
	    instead of <SPAN
CLASS="TYPE"
>LocalRecord</SPAN
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct _MyLocalRecord {
        LocalRecord local;
        gpointer my_data;
};

typedef struct _MyLocalRecord MyLocalRecord;
#define MY_LOCAL_RECORD(s) ((MyLocalRecord*)(s))

static gint
my_conduit_match_record (GnomePilotConduitStandardAbs *conduit,
                         LocalRecord **local,
                         PilotRecord *remote,
                         gpointer data)
{
        g_return_val_if_fail(local!=NULL,0);
        g_return_val_if_fail(remote!=NULL,0);

        (*local) = g_new0(MyLocalRecord,1);
        (*local)-&#62;local = my_conduit_determine_local_record_values(remote);
        (*local)-&#62;my_data = my_conduit_determine_local_record_my_data(remote);

        return 0;
}

static gint
my_conduit_set_pilot_id (GnomePilotConduitStandardAbs *conduit,
                         MyLocalRecord *local,
                         guint32 new_id,
                         gpointer data)
{
        MyLocalRecord *my_local;

        g_return_val_if_fail(local!=NULL,0);
        g_return_val_if_fail(*local!=NULL,0);

        my_local = MY_LOCAL_RECORD(local);

        my_local-&#62;local.ID = new_id;

        my_conduit_save_my_local_record(my_local);

        return 0;
}

GnomePilotConduit *
conduit_get_gpilotd_conduit( guint32 pilotId) 
{ 
        GnomePilotConduitStandardAbs *retval;
 
        /* create a new conduit for the pilots database called
           MemoDB, which has a creator id of 0x6d656d6f */
        retval = gnome_pilot_conduit_standard_abs_new("MemoDB",0x6d656d6f);
     
        /* load configuration, see later */

        my_records = my_conduit_load_records(pilotId);
        gtk_signal_connect(retval,"match_record",
                           (GtkSignalFunc)my_conduit_match_record,
                           NULL);
        gtk_signal_connect(retval,"set_pilot_id",
                           (GtkSignalFunc)my_conduit_set_pilot_id,
                           NULL);
        /* gtk_signal_connect for the rest of the signals */

        return GNOME_PILOT_CONDUIT(retval);
}</PRE
></TD
></TR
></TABLE
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1181"
>Conduit data fields</A
></H2
><P
>Data fields are
	specielt parameters set using the
	<TT
CLASS="FUNCTION"
>gtk_object_set_data</TT
> call.</P
><P
></P
><UL
><LI
><P
><TT
CLASS="FUNCTION"
>"db_open_mode"</TT
> can be set to
	    regulate the mode in which the pilots database is
	    opened. This should be one of the enums found in
	    <TT
CLASS="FILENAME"
>pi-dlp.h</TT
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
>note: this is
	    subject to change when the conduits no longer should use
	    pilot-link calls/enums.</BLOCKQUOTE
></DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>enum dlpOpenFlags {
        dlpOpenRead = 0x80,
        dlpOpenWrite = 0x40,
        dlpOpenExclusive = 0x20,
        dlpOpenSecret = 0x10,
        dlpOpenReadWrite = 0xC0
};</PRE
></TD
></TR
></TABLE
><P
>Typically, the conduit will not want to set it, in
	    which case the db is opened in ReadWrite mode, but the
	    conduit may want to set the datafield to
	    <TT
CLASS="FUNCTION"
>dlpOpenReadWrite|dlpOpenSecret</TT
> to access
	    records marked as secret.</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x61.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="gnome-pilot-conduit-design.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="conduit-capplet.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Beginning conduit implemention</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Conduit control-center applet</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>