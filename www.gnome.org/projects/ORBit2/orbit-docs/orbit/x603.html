<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>&#13;Account Client and Server
</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="ORBit Beginners Documentation"
HREF="book1.html"><LINK
REL="UP"
TITLE="First CORBA Programs"
HREF="c226.html"><LINK
REL="PREVIOUS"
TITLE="Calculator Client Server"
HREF="x430.html"><LINK
REL="NEXT"
TITLE="How to do garbage collection under CORBA"
HREF="c726.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ORBit Beginners Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x430.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>First CORBA Programs</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c726.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN603"
></A
>Account Client and Server</H1
><P
>&#13;In this third simple example, we will see how we can set up a 
client that can modify the value of a variable stored on the server. 
It is basically the way an account manager works. 
The stored variable here is balance. 
The idl definition (<TT
CLASS="filename"
>account.idl</TT
>) for our account is : 
<DIV
CLASS="example"
><A
NAME="AEN607"
></A
><P
><B
>Example 15. account.idl</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;   interface Account {
      void deposit (in unsigned long amount);
      void withdraw (in unsigned long amount);
      readonly attribute long balance;
   };</PRE
></TD
></TR
></TABLE
></DIV
>

Then you have to generate the skeleton and stub files. In addition to
these two files the ORBit IDL compiler also generates a common file
and a header file. The common file implements the memory management
functions and other things, useful in the client as well as in the
server. The sequence to generate the C source files is rather
simple.
<TT
CLASS="computeroutput"
>$ <B
CLASS="command"
>orbit-idl-2 --skeleton-impl
calculator.idl</B
>
</TT
>
geenrates all the files we will use in this example.

<DIV
CLASS="informaltable"
><A
NAME="AEN612"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>File</TH
><TH
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>Usage for Client</TH
><TH
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>Usage for Server</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>account.h</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>account-common.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>account-stubs.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>-</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>account-skels.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>-</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>account-skelimpl.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>-</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>template for user code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>

Files remaining to write are listed in following table, starting with 
<I
CLASS="emphasis"
>account-client.c</I
> in following chapter.
<DIV
CLASS="informaltable"
><A
NAME="AEN644"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>account-client.c</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>write the client code</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>account-server.c</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>write the generic code for servant creation</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>


</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN653"
></A
>Account Client</H2
><P
>&#13;There is no difficulty in setting the client (at least no more than in the previous examples).
Only one thing has been added : we test for the availabilty of the server 
(<TT
CLASS="function"
>if (!acc_client) </TT
> ...) 
before invoking calls to the server.
</P
><P
>&#13;<DIV
CLASS="example"
><A
NAME="AEN658"
></A
><P
><B
>Example 16. account-client.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>/* account-client.c hacked by Frank Rehberger
 * &#60;F.Rehberger@xtradyne.de&#62;.  */

#include &#60;assert.h&#62;
#include &#60;stdio.h&#62;
#include &#60;orbit/orbit.h&#62;

#include "account.h"

/** 
 * test for exception 
 */
static
gboolean 
raised_exception(CORBA_Environment *ev) 
{
	return ((ev)-&#62;_major != CORBA_NO_EXCEPTION);
}

/**
 * in case of any exception this macro will abort the process  
 */
static
void 
abort_if_exception(CORBA_Environment *ev, const char* mesg) 
{
	if (raised_exception (ev)) {
		g_error ("%s %s", mesg, CORBA_exception_id (ev));
		CORBA_exception_free (ev); 
		abort(); 
	}
}

/*
 * main 
 */
int
main(int argc, char* argv[])
{
	char*             ior=NULL;
	CORBA_long        val=0;
        CORBA_long        balance=0;
	
        CORBA_ORB         orb;
        Account           server;

        CORBA_Environment ev[1];
        CORBA_exception_init(ev);

	/* init - ORB might 'eat' arguments from command line */
        <B
CLASS="command"
>orb = CORBA_ORB_init(&#38;argc, argv, "orbit-local-orb", ev);</B
>
	abort_if_exception(ev, "init failed");

	/* make sure command lines contains two arguments; IOR and
	 * integer value  */
	if (argc&#60;3)
		g_error ("usage: %s &#60;ior&#62; &#60;int&#62;", argv[0]);
	ior = argv[1];
	val = atoi(argv[2]);

	/* establish servant connection */
        <B
CLASS="command"
>server = (Account) CORBA_ORB_string_to_object(orb, ior, ev);</B
>
	abort_if_exception(ev, "bind failed");

	/* 
	 * use calculator server 
	 */ 
	
        <B
CLASS="command"
>balance = Account__get_balance (server, ev);</B
>
	abort_if_exception(ev, "service not reachable");
	
	g_print ("balance %5d, ", balance);
	
	if (val &#62; 0)
	{
		<B
CLASS="command"
>Account_deposit (server, val, ev);</B
>
		abort_if_exception(ev, "service not reachable");
	}
	else
	{
		<B
CLASS="command"
>Account_withdraw (server, abs(val), ev);</B
>
		abort_if_exception(ev, "service not reachable");
	}
	
        <B
CLASS="command"
>balance = Account__get_balance (server, ev);</B
>
	abort_if_exception(ev, "service not reachable");
	
	g_print ("new balance %5d\n", balance);
	
	/* tear down object reference and ORB */
        <B
CLASS="command"
>CORBA_Object_release(server,ev);</B
>
	abort_if_exception(ev, "releasing service failed");

	<B
CLASS="command"
>CORBA_ORB_destroy (orb, ev);</B
>
	abort_if_exception(ev, "cleanup failed");

	/* successfull termination */
	exit(0);
}</PRE
></TD
></TR
></TABLE
></DIV
>
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN669"
></A
>Account Server</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN671"
></A
>Account Server Skeleton Implementation</H3
><P
>&#13;
For the server, like in the previous example, we first generate the source file
<TT
CLASS="filename"
>account-skelimpl.c</TT
> 
that will receive the implementation code for
the methods.
This is done once again with <TT
CLASS="userinput"
><B
>orbit-idl-2 --skeleton-impl
account.idl</B
></TT
>.
</P
><P
>&#13;Now, let us edit <TT
CLASS="filename"
>account-skelimpl.c</TT
>. 
We search for the the <TT
CLASS="varname"
>balance</TT
> attribute that was declared
in the IDL file. 
At the beginning of the file, we can spot the way it has been translated into
C by the idl compiler:

<DIV
CLASS="example"
><A
NAME="AEN679"
></A
><P
><B
>Example 17. 
account-skelimpl.c fragment - object declaration
</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef struct
{
   POA_Account servant;
   PortableServer_POA poa;

   CORBA_long attr_balance;

   /* ------ add private attributes here ------ */
   <B
CLASS="command"
>CORBA_long attr_balance;</B
>
   /* ------ ---------- end ------------ ------ */
}
impl_POA_Account;</PRE
></TD
></TR
></TABLE
></DIV
>
So, the server methods (withdraw and deposit) will have to manage the balance
of the account through the <TT
CLASS="varname"
>servant-&#62;attr_balance</TT
> (the
servant variable is passed as parameter to each method).
</P
><P
>&#13;Now, let us get to the end of the file and find the methods stubs.
We find the <TT
CLASS="function"
>impl_Account_*</TT
> functions, to which we add the
implementation code. 
This could be:
</P
><DIV
CLASS="example"
><A
NAME="AEN686"
></A
><P
><B
>Example 18. 
account-skelimpl.c fragment - method definition
</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>static void
impl_Account_deposit(impl_POA_Account * servant,
		     const CORBA_unsigned_long amount, CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   <B
CLASS="command"
>servant-&#62;attr_balance += amount;</B
>
   /* ------ ---------- end ------------ ------ */
}

static void
impl_Account_withdraw(impl_POA_Account * servant,
		      const CORBA_unsigned_long amount,
		      CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   <B
CLASS="command"
>servant-&#62;attr_balance -= amount;</B
>
   /* ------ ---------- end ------------ ------ */
}

static CORBA_long
impl_Account__get_balance(impl_POA_Account * servant, CORBA_Environment * ev)
{
   CORBA_long retval;

   /* ------   insert method code here   ------ */
   <B
CLASS="command"
>retval = servant-&#62;attr_balance;</B
>
   /* ------ ---------- end ------------ ------ */

   return retval;
}</PRE
></TD
></TR
></TABLE
></DIV
><P
>The missing key stone is the constructor that establishs
initial, consistent state for object on creation.</P
><DIV
CLASS="example"
><A
NAME="AEN693"
></A
><P
><B
>Example 19. 
account-skelimpl.c fragment - constructor
</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>...
static Account
impl_Account__create(PortableServer_POA poa, CORBA_Environment * ev)
{
   Account retval;
   impl_POA_Account *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Account, 1);
   newservant-&#62;servant.vepv = &#38;impl_Account_vepv;
   newservant-&#62;poa = poa;
   POA_Account__init((PortableServer_Servant) newservant, ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   <B
CLASS="command"
>newservant-&#62;attr_balance = 0;</B
>
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}
..</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN697"
></A
>Account Server Implementation</H3
><P
>&#13;Lastly, we have to write a rather generic code to set up the server.
We call it <TT
CLASS="filename"
>account-server.c</TT
>.
It is roughly the same code as in the calculator and echo examples.
The code just initializes the ORB and publishes an IOR for the server object.
</P
><DIV
CLASS="example"
><A
NAME="AEN701"
></A
><P
><B
>Example 20. 
account-server.c 
</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>/*
 * account-server program. Hacked from Frank Rehberger
 * &#60;F.Rehberger@xtradyne.de&#62;.
 */

#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;signal.h&#62;
#include &#60;orbit/orbit.h&#62;

<B
CLASS="command"
>#include "account.h"</B
>
<B
CLASS="command"
>#include "account-skelimpl.c"</B
>

/** 
 * test for exception */
static
gboolean 
raised_exception(CORBA_Environment *ev) {
	return ((ev)-&#62;_major != CORBA_NO_EXCEPTION);
}

/**
 * in case of any exception this macro will abort the process  */
static
void 
abort_if_exception(CORBA_Environment *ev, const char* mesg) 
{    
	if (raised_exception (ev)) {
		g_error ("%s %s", mesg, CORBA_exception_id (ev));
		CORBA_exception_free (ev); 
		abort(); 
	}
}

static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
account_server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                <B
CLASS="command"
>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</B
>
                abort_if_exception (local_ev, "ORB shutdown failed");

                global_orb=CORBA_OBJECT_NIL;
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * consumed option from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * account_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
account_server_init (int               *argc_ptr, 
		     char              *argv[],
		     CORBA_ORB         *orb,
		     CORBA_Environment *ev)
{
	/* init signal handling */

	signal(SIGINT,  account_server_shutdown);
	signal(SIGTERM, account_server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
        <B
CLASS="command"
>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-orb", ev);</B
>
	if (raised_exception(ev)) return;
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static 
Account
account_server_activate_service (CORBA_ORB         orb,
				 CORBA_Environment *ev)
{
	Account                    servant     = CORBA_OBJECT_NIL; 
	PortableServer_POA         poa         = CORBA_OBJECT_NIL; 
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

        /* get Portable Object Adaptor (POA) */

        <B
CLASS="command"
>poa = 
	 (PortableServer_POA) CORBA_ORB_resolve_initial_references(orb,
								   "RootPOA",
								   ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;

       /* create servant in context of poa container */

	<B
CLASS="command"
>servant = impl_Account__create (poa, ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;
	
        /* activate POA Manager */

        <B
CLASS="command"
>poa_manager = PortableServer_POA__get_the_POAManager(poa, ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;

	<B
CLASS="command"
>PortableServer_POAManager_activate(poa_manager, ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;

	return servant;
}

/* Writes stringified object reference of @servant to file-stream
 * @stream. If error occures @ev points to exception object on
 * return.
 */
static 
void 
account_server_export_service_to_stream (CORBA_ORB          orb,
					 Account            servant,
					 FILE              *stream, 
					 CORBA_Environment *ev)
{
        CORBA_char *objref = NULL;

	/* write objref to file */
	
        <B
CLASS="command"
>objref = CORBA_ORB_object_to_string (orb, servant, ev);</B
>
	if (raised_exception(ev)) return;

        /* print ior to terminal */
	fprintf (stream, "%s\n", objref);
	fflush (stream);

        CORBA_free (objref);
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static 
void 
account_server_run (CORBA_ORB          orb,
		    CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
        <B
CLASS="command"
>CORBA_ORB_run(orb, ev);</B
>
	if (raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static 
void account_server_cleanup (CORBA_ORB          orb,
			     Account            servant,
			     CORBA_Environment *ev)
{
	/* releasing managed object */
        <B
CLASS="command"
>CORBA_Object_release(servant, ev);</B
>
	if (raised_exception(ev)) return;

        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                CORBA_ORB_destroy(orb, ev);
		if (raised_exception(ev)) return;
        }
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	Account servant = CORBA_OBJECT_NIL;

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	<B
CLASS="command"
>account_server_init (&#38;argc, argv, &#38;global_orb, ev);</B
>
	abort_if_exception(ev, "init failed");

	<B
CLASS="command"
>servant = account_server_activate_service (global_orb, ev);</B
>
	abort_if_exception(ev, "activating service failed");

	<B
CLASS="command"
>account_server_export_service_to_stream (global_orb, /* ORB    */ 
						 servant,    /* object */ 
						 stdout,     /* stream */ 
						 ev);       </B
>
	abort_if_exception(ev, "exporting IOR failed");
	
	<B
CLASS="command"
>account_server_run (global_orb, ev);</B
>
	abort_if_exception(ev, "entering main loop failed");

	<B
CLASS="command"
>account_server_cleanup (global_orb, servant, ev);</B
>
	abort_if_exception(ev, "cleanup failed");

	exit (0);
}</PRE
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN720"
></A
>Compiling the Server and the Client</H2
><P
>&#13;The Makefile is the roughly the same as the one in the Calculator
example. By now the schema should be clear and you should be able to
reuse this Makefile for numerous small projects.
<DIV
CLASS="example"
><A
NAME="AEN723"
></A
><P
><B
>Example 21. Makefile for the Account example</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>CC = gcc
CC = gcc
TARGETS=account-client account-server
ORBIT_IDL=orbit-idl-2
CFLAGS= -DORBIT2=1 -D_REENTRANT -I/usr/include/orbit-2.0 \
         -I/usr/include/linc-1.0 -I/usr/include/glib-2.0 \
         -I/usr/lib/glib-2.0/include
LDFLAGS= -Wl,--export-dynamic -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm
IDLOUT=account-common.c account-stubs.c account-skels.c account.h

all: $(IDLOUT) account-client account-server

account-client : account-client.o account-common.o account-stubs.o 
account-server : account-server.o account-common.o account-skels.o 

$(IDLOUT): account.idl
	$(ORBIT_IDL) account.idl

clean:
	rm -rf *.o *~ $(IDLOUT)
</PRE
></TD
></TR
></TABLE
></DIV
>
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x430.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c726.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Calculator Client Server</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c226.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>How to do garbage collection under CORBA</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>