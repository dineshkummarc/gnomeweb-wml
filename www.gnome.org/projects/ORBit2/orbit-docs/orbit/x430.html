<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Calculator Client Server</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="ORBit Beginners Documentation V1.2"
HREF="book1.html"><LINK
REL="UP"
TITLE="First CORBA Programs"
HREF="c226.html"><LINK
REL="PREVIOUS"
TITLE="Echo client and server"
HREF="x278.html"><LINK
REL="NEXT"
TITLE="
Account Client and Server
"
HREF="x603.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ORBit Beginners Documentation V1.2</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x278.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>First CORBA Programs</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x603.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="calculator-IDL"
></A
>Calculator Client Server</H1
><P
>&#13;This example will take you further into understanding how to actually
make a working server, using the support that comes from ORBit. It
will demonstrate handling of replies from server.
</P
><P
>&#13;
The system will not be doing very much. The server just provides two
functions, one to add two numbers and one to subtract two numbers. The
first thing you have to do is to write the IDL files for the
server. In our example it is very simple.
<DIV
CLASS="example"
><A
NAME="AEN434"
></A
><P
><B
>Example 9. calculator.idl</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;
interface Calculator
{
      double add(in double number1, in double number2);
      double sub(in double number1, in double number2);
};

</PRE
></TD
></TR
></TABLE
></DIV
>

Then you have to generate the skeleton and stub files. In addition to
these two files the ORBit IDL compiler also generates a common file
and a header file. The common file implements the memory management
functions and other things, useful in the client as well as in the
server. The sequence to generate the C source files is rather
simple.
<TT
CLASS="computeroutput"
>$ <B
CLASS="command"
>orbit-idl-2 --skeleton-impl
calculator.idl</B
>
</TT
>
geenrates all the files we will use in this example.

<DIV
CLASS="informaltable"
><A
NAME="AEN439"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>File</TH
><TH
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>Usage for Client</TH
><TH
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>Usage for Server</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>calculator.h</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>calculator-common.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>calculator-stubs.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>-</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>calculator-skels.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>-</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>readonly</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>calculator-skelimpl.c</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>-</TD
><TD
WIDTH="33%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>template for user code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>

Files remaining to write are listed in following table, starting with 
<I
CLASS="emphasis"
>calculator-client.c</I
> in following chapter.
<DIV
CLASS="informaltable"
><A
NAME="AEN471"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>calculator-client.c</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>write the client code</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>calculator-server.c</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>write the generic code for servant creation</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>


</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="calculator-client"
></A
>Calculator Client</H2
><P
>&#13;The next thing you have to do is to write the server and client
programs. We start with the client, because it's easier and not very
complicated. 
</P
><P
>&#13;  A simple implementation of the client might look like this
  <DIV
CLASS="example"
><A
NAME="AEN484"
></A
><P
><B
>Example 10. calculator-client.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>/* calculator-client.c hacked by Frank Rehberger
 * &#60;F.Rehberger@xtradyne.de&#62;.  */

#include &#60;assert.h&#62;
#include &#60;stdio.h&#62;
#include &#60;orbit/orbit.h&#62;

#include "calculator.h"

/** 
 * test for exception 
 */
static
gboolean 
raised_exception(CORBA_Environment *ev) 
{
	return ((ev)-&#62;_major != CORBA_NO_EXCEPTION);
}

/**
 * in case of any exception this macro will abort the process  
 */
static
void 
abort_if_exception(CORBA_Environment *ev, const char* mesg) 
{
	if (raised_exception (ev)) {
		g_error ("%s %s", mesg, CORBA_exception_id (ev));
		CORBA_exception_free (ev); 
		abort(); 
	}
}

/*
 * main 
 */
int
main(int argc, char* argv[])
{
	char*             ior;

        CORBA_ORB         orb;
        CORBA_Object      server;

        CORBA_double      result=0.0;
	
        CORBA_Environment ev[1];
        CORBA_exception_init(ev);

	/* init - ORB might 'eat' arguments from command line */
        <B
CLASS="command"
>orb = CORBA_ORB_init(&#38;argc, argv, "orbit-local-orb", ev);</B
>
	abort_if_exception(ev, "init ORB failed");

	/* make sure servant's IOR is given as command argument */
	if (argc&#60;2)
		g_error ("usage: %s &#60;ior&#62;", argv[0]);
	ior=argv[1];
	
	/* establish servant connection */
        <B
CLASS="command"
>server = CORBA_ORB_string_to_object(orb, ior, ev);</B
>
	abort_if_exception(ev, "bind failed");

	/* 
	 * use calculator server 
	 */ 
        <B
CLASS="command"
>result = Calculator_add(server, 1.0, 2.0, ev);</B
>
	abort_if_exception(ev, "service not reachable");

	/* prints results to console */
        g_print("Result: 1.0 + 2.0 = %2.0f\n", result);

	/* tear down object reference and ORB */
        <B
CLASS="command"
>CORBA_Object_release(server,ev);</B
>
	abort_if_exception(ev, "releasing service failed");

	<B
CLASS="command"
>CORBA_ORB_destroy (orb, ev);</B
>
	abort_if_exception(ev, "cleanup failed");

	/* successfull termination */
	exit(0);
}</PRE
></TD
></TR
></TABLE
></DIV
>
</P
><P
>&#13;Rather simple, but full of unexplained stuff.
Let's take a close look to the defined variables.

        <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="parameter"
><I
>&#13;                env </I
></TT
></DT
><DD
><P
>&#13;	      This varaible is used to hold information about
	      exceptions which might have occurred during a function
	      call. How to use this variable to detect errors in
	      function will be explained in a later example.
	      </P
></DD
><DT
><TT
CLASS="parameter"
><I
>&#13;             orb
            </I
></TT
></DT
><DD
><P
>&#13;This is the ORB itself.
              </P
></DD
><DT
><TT
CLASS="parameter"
><I
>&#13;              server
            </I
></TT
></DT
><DD
><P
>&#13;	      This is the object reference to the server.
	      </P
></DD
></DL
></DIV
>
</P
><P
>&#13;The example above is a full functional client. 
The magic in this
example is the usage of the function
<I
CLASS="emphasis"
>CORBA_ORB_string_to_object</I
> with the parameter
<TT
CLASS="parameter"
><I
>argv[1]</I
></TT
>. The explantion is that the program is
supposed to be called with the string representation of the Calculator 
server as the first parameter. How to obtain this string, will be
shown in the next example, where I describe how the server.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="calculator-server"
></A
>Calculator Server</H2
><P
>&#13;To implement the server, the IDL compiler does a great deal of work
for you. It can emit all the stuff necessary to set up the data
structures and function calls for the server implementation. All you
have to write is the setup stuff in your main function and the actual
implementation of the server functions. First I'll present the
functions and data structures the IDL compiler generates and then I'll 
show what's necessary to set up the environment for these functions to
work properly.
</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="calculator-server-idl"
></A
>Calculator Implementation Skeleton</H3
><P
>&#13;To ease the task of implementing the calculator the ORBit IDL compiler
can output an implementation skeleton of the server. 
This is enabled with the --skeleton-impl switch to the IDL compiler. 
The output of <B
CLASS="command"
>orbit-idl-2 --skeleton-impl calculator.idl</B
> looks like this (the default name for the generated source file is <TT
CLASS="filename"
>calculator-skelimpl.c</TT
>:

<DIV
CLASS="example"
><A
NAME="AEN520"
></A
><P
><B
>Example 11. calculator-skelimpl.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>#include "calculator.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Calculator servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */
   /* ------ ---------- end ------------ ------ */
}
impl_POA_Calculator;

/*** Implementation stub prototypes ***/

static void impl_Calculator__destroy(impl_POA_Calculator * servant,
				     CORBA_Environment * ev);
static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, 
		    CORBA_Environment * ev);

static CORBA_double
impl_Calculator_sub(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, 
		    CORBA_Environment * ev);

/*** epv structures ***/

static PortableServer_ServantBase__epv impl_Calculator_base_epv = {
   NULL,			/* _private data */
   (gpointer) &#38; impl_Calculator__destroy,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Calculator__epv impl_Calculator_epv = {
   NULL,			/* _private */
   (gpointer) &#38; impl_Calculator_add,

   (gpointer) &#38; impl_Calculator_sub,

};

/*** vepv structures ***/

static POA_Calculator__vepv impl_Calculator_vepv = {
   &#38;impl_Calculator_base_epv,
   &#38;impl_Calculator_epv,
};

/*** Stub implementations ***/

static Calculator
impl_Calculator__create(PortableServer_POA poa, 
                        CORBA_Environment * ev)
{
   Calculator retval;
   impl_POA_Calculator *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Calculator, 1);
   newservant-&#62;servant.vepv = &#38;impl_Calculator_vepv;
   newservant-&#62;poa = poa;
   POA_Calculator__init((PortableServer_Servant) newservant, ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

static void
impl_Calculator__destroy(impl_POA_Calculator * servant,
			 CORBA_Environment * ev)
{
   CORBA_Object_release((CORBA_Object) servant-&#62;poa, ev);
 
   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */
   /* ------ ---------- end ------------- ------ */

   POA_Calculator__fini((PortableServer_Servant) servant, ev);
}

static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
		    const CORBA_double number1,
		    const CORBA_double number2, 
		    CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   <B
CLASS="command"
>retval = number1 + number2;</B
>
   /* ------ ---------- end ------------ ------ */

   return retval;
}

static CORBA_double
impl_Calculator_sub(impl_POA_Calculator * servant,
                    const CORBA_double number1,
                    const CORBA_double number2, 
		    CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   <B
CLASS="command"
>retval = number1 - number2;</B
>
   /* ------ ---------- end ------------ ------ */

   return retval;
}</PRE
></TD
></TR
></TABLE
></DIV
>
</P
><P
>&#13;This source file provides you with most of the magic of a server. 
Note that we generate this file (with the <B
CLASS="command"
>--skeleton-impl</B
> switch) only once, 
and then the makefile invokes <B
CLASS="command"
>orbit-idl-2</B
> with no switch.
If you call <B
CLASS="command"
>orbit-idl-2 --skeleton-impl</B
> from the makefile, the previous file will be overwritten and your implementation code lost.
Once the implementation code is written, just include the source file at the
beginning of the
<TT
CLASS="filename"
>calculator-server.c</TT
> file. 
</P
><P
>&#13;For
this first example, I won't explain all the bits and pieces of the
generated source file. This will be done later. We'll just concentrate on 
getting the server running.
</P
><P
>&#13;As you see there are two functions:
<DIV
CLASS="funcsynopsis"
><A
NAME="AEN532"
></A
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>CORBA_double <TT
CLASS="function"
>impl_Calculator_add</TT
></CODE
>(impl_POA_Calculator* <TT
CLASS="parameter"
><I
>servant</I
></TT
>, CORBA_double <TT
CLASS="parameter"
><I
>number1</I
></TT
>, CORBA_double <TT
CLASS="parameter"
><I
>number2</I
></TT
>, CORBA_Environment* <TT
CLASS="parameter"
><I
>ev</I
></TT
>);</CODE
></P
><P
></P
></DIV
>
and
<DIV
CLASS="funcsynopsis"
><A
NAME="AEN544"
></A
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>CORBA_double <TT
CLASS="function"
>impl_Calculator_sub</TT
></CODE
>(impl_POA_Calculator* <TT
CLASS="parameter"
><I
>servant</I
></TT
>, CORBA_double <TT
CLASS="parameter"
><I
>number1</I
></TT
>, CORBA_double <TT
CLASS="parameter"
><I
>number2</I
></TT
>, CORBA_Environment* <TT
CLASS="parameter"
><I
>ev</I
></TT
>);</CODE
></P
><P
></P
></DIV
>

These two functions are implementing the function defined in the IDL
file. Because the IDL compiler doesn't provide you with a real
implementation (it doesn't know what the function should do), you have 
to extend this skeleton yourself where marked.
</P
><P
>&#13;The <TT
CLASS="function"
>impl_Calculator_add()</TT
> should add it's two 
parameters and return the result so this function should be changed
into:

<DIV
CLASS="example"
><A
NAME="AEN558"
></A
><P
><B
>Example 12. calculator-skelimpl.c fragment</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;static CORBA_double
impl_Calculator_add(impl_POA_Calculator * servant,
                    const CORBA_double number1,
                    const CORBA_double number2, 
		    CORBA_Environment * ev)
{
   CORBA_double retval;

   /* ------   insert method code here   ------ */
   <B
CLASS="command"
>retval = number1 + number2;</B
>
   /* ------ ---------- end ------------ ------ */

   return retval;
}</PRE
></TD
></TR
></TABLE
></DIV
>
</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="calculator-server-main"
></A
>Calculator Server Implementation</H3
><P
>&#13;The things you need in your minimal main function to make things work
can be implemented in the following way, note analogy to
<TT
CLASS="filename"
>echo-server.c</TT
> of previous example.

          <DIV
CLASS="example"
><A
NAME="AEN566"
></A
><P
><B
>Example 13. calculator-server.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>/*
 * calculator-server program. Hacked from Frank Rehberger
 * &#60;F.Rehberger@xtradyne.de&#62;.
 */

#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;signal.h&#62;
#include &#60;orbit/orbit.h&#62;

<B
CLASS="command"
>#include "calculator.h"</B
>
<B
CLASS="command"
>#include "calculator-skelimpl.c"</B
>

/** 
 * test for exception */
static
gboolean 
raised_exception(CORBA_Environment *ev) {
	return ((ev)-&#62;_major != CORBA_NO_EXCEPTION);
}

/**
 * in case of any exception this macro will abort the process  */
static
void 
abort_if_exception(CORBA_Environment *ev, const char* mesg) 
{
	if (raised_exception (ev)) {
		g_error ("%s %s", mesg, CORBA_exception_id (ev));
		CORBA_exception_free (ev); 
		abort(); 
	}
}

static CORBA_ORB  global_orb = CORBA_OBJECT_NIL; /* global orb */
	
/* Is called in case of process signals. it invokes CORBA_ORB_shutdown()
 * function, which will terminate the processes main loop.
 */
static
void
calculator_server_shutdown (int sig)
{
	CORBA_Environment  local_ev[1];
	CORBA_exception_init(local_ev);

        if (global_orb != CORBA_OBJECT_NIL)
        {
                <B
CLASS="command"
>CORBA_ORB_shutdown (global_orb, FALSE, local_ev);</B
>
                 abort_if_exception (local_ev, "ORB shutdown failed");

                global_orb=CORBA_OBJECT_NIL;
        }
}

/* Inits ORB @orb using @argv arguments for configuration. For each
 * consumed option from vector @argv the counter of @argc_ptr
 * will be decremented. Signal handler is set to call
 * calculator_server_shutdown function in case of SIGINT and SIGTERM
 * signals.  If error occures @ev points to exception object on
 * return.
 */static 
void 
calculator_server_init (int               *argc_ptr, 
			char              *argv[],
			CORBA_ORB         *orb,
			CORBA_Environment *ev)
{
	/* init signal handling */

	signal(SIGINT,  calculator_server_shutdown);
	signal(SIGTERM, calculator_server_shutdown);
	
	/* create Object Request Broker (ORB) */
	
        <B
CLASS="command"
>(*orb) = CORBA_ORB_init(argc_ptr, argv, "orbit-local-orb", ev);</B
>
	if (raised_exception(ev)) return;
}

/* Creates servant and registers in context of ORB @orb. The ORB will
 * delegate incoming requests to specific servant object.  @return
 * object reference. If error occures @ev points to exception object
 * on return.
 */
static 
Calculator
calculator_server_activate_service (CORBA_ORB         orb,
				    CORBA_Environment *ev)
{
	Calculator                 servant     = CORBA_OBJECT_NIL; 
	PortableServer_POA         poa         = CORBA_OBJECT_NIL; 
	PortableServer_POAManager  poa_manager = CORBA_OBJECT_NIL; 

        /* get Portable Object Adaptor (POA) */

        poa = 
	 <B
CLASS="command"
>(PortableServer_POA) CORBA_ORB_resolve_initial_references(orb,
								   "RootPOA",
								   ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;

       /* create servant in context of poa container */

	<B
CLASS="command"
>servant = impl_Calculator__create (poa, ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;
	
        /* activate POA Manager */

        <B
CLASS="command"
>poa_manager = PortableServer_POA__get_the_POAManager(poa, ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;

	<B
CLASS="command"
>PortableServer_POAManager_activate(poa_manager, ev);</B
>
	if (raised_exception(ev)) return CORBA_OBJECT_NIL;

	return servant;
}

/* Writes stringified object reference of @servant to file-stream
 * @stream. If error occures @ev points to exception object on
 * return.
 */
static 
void 
calculator_server_export_service_to_stream (CORBA_ORB          orb,
					    Calculator         servant,
					    FILE              *stream, 
					    CORBA_Environment *ev)
{
        CORBA_char *objref = NULL;

	/* write objref to file */
	
        <B
CLASS="command"
>objref = CORBA_ORB_object_to_string (orb, servant, ev);</B
>
	if (raised_exception(ev)) return;

        /* print ior to terminal */
	<B
CLASS="command"
>fprintf (stream, "%s\n", objref);</B
>
	fflush (stream);

        CORBA_free (objref);
}

/* Entering main loop @orb handles incoming request and delegates to
 * servants. If error occures @ev points to exception object on
 * return.
 */
static 
void 
calculator_server_run (CORBA_ORB          orb,
		       CORBA_Environment *ev)
{
        /* enter main loop until SIGINT or SIGTERM */
	
        <B
CLASS="command"
>CORBA_ORB_run(orb, ev);</B
>
	if (raised_exception(ev)) return;

        /* user pressed SIGINT or SIGTERM and in signal handler
	 * CORBA_ORB_shutdown(.) has been called */
}

/* Releases @servant object and finally destroys @orb. If error
 * occures @ev points to exception object on return.
 */
static 
void calculator_server_cleanup (CORBA_ORB          orb,
				Calculator         servant,
				CORBA_Environment *ev)
{
	/* releasing managed object */
        <B
CLASS="command"
>CORBA_Object_release(servant, ev);</B
>
	if (raised_exception(ev)) return;

        /* tear down the ORB */
        if (orb != CORBA_OBJECT_NIL)
        {
                /* going to destroy orb.. */
                <B
CLASS="command"
>CORBA_ORB_destroy(orb, ev);</B
>
		if (raised_exception(ev)) return;
        }
}

/* 
 * main 
 */

int
main (int argc, char *argv[])
{
	Calculator servant = CORBA_OBJECT_NIL;

	CORBA_Environment  ev[1];
	CORBA_exception_init(ev);
	
	<B
CLASS="command"
>calculator_server_init (&#38;argc, argv, &#38;global_orb, ev);</B
>
	abort_if_exception(ev, "init failed");

	<B
CLASS="command"
>servant = calculator_server_activate_service (global_orb, ev);</B
>
	abort_if_exception(ev, "activating service failed");

	<B
CLASS="command"
>calculator_server_export_service_to_stream (global_orb, /* ORB    */ 
						    servant,    /* object */ 
						    stdout,     /* stream */ 
						    ev);</B
>   
	abort_if_exception(ev, "exporting IOR failed");
	
	<B
CLASS="command"
>calculator_server_run (global_orb, ev);</B
>
	abort_if_exception(ev, "entering main loop failed");

	<B
CLASS="command"
>calculator_server_cleanup (global_orb, servant, ev);</B
>
	abort_if_exception(ev, "cleanup failed");

	exit (0);
}</PRE
></TD
></TR
></TABLE
></DIV
> </P
><P
> I'm not
going to explain every line of this example yet, because we want the
server up and make our first calls to it. Though one line deserves
some explanation and this is the <TT
CLASS="function"
>fprintf(stream,
"%s\n",objref)</TT
> call. The purpose of this call is to print
the string representation of the the object reference. This string,
which always starts with the magic sequence "IOR:", is the argument to
the client program. It identifies a specific object, the server
process which hosts it, the location of the server, and the identity
of the object in this specific server, because it's possible that one
server hosts many objects.  How to get such strings or object
references without cutting the output of one program (the server) and
pasting it into the commandline of another program (the client) will
be explained later.  </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="calculator-compilation"
></A
>Compiling and
Running the Server and the Client</H2
><P
> The following
makefile can be used to compile both, the client and the server. Be
aware of the location of ORBit : on my system it has been installed
under /usr but it could be /usr/local if you have built it from the
sources, and hence the path for ORBIT variables below may
vary. If using ORBit binary packages shipped with Linux or BSD/Unix the simple makefile below will do.
<DIV
CLASS="example"
><A
NAME="AEN592"
></A
><P
><B
>Example 14. makefile</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>PREFIX=/usr/local
CC = gcc
TARGETS=calculator-client calculator-server
ORBIT_IDL=orbit-idl-2
CFLAGS=-DORBIT2=1 -D_REENTRANT -I$(PREFIX)/include/orbit-2.0 \
       -I$(PREFIX)/include/linc-1.0 -I$(PREFIX)/include/glib-2.0 \
       -I$(PREFIX)/lib/glib-2.0/include
LDFLAGS= -Wl,--export-dynamic -L$(PREFIX)/lib -lORBit-2 -llinc -lgmodule-2.0 \
             -ldl -lgobject-2.0 -lgthread-2.0 -lpthread -lglib-2.0 -lm
IDLOUT=calculator-common.c calculator-stubs.c calculator-skels.c calculator.h
 
all: $(IDLOUT) calculator-client calculator-server
 
calculator-client : calculator-client.o calculator-common.o calculator-stubs.o
calculator-server : calculator-server.o calculator-common.o calculator-skels.o
 
$(IDLOUT): calculator.idl
        $(ORBIT_IDL) calculator.idl
 
clean:
        rm -rf *.o *~ $(IDLOUT)
 
distclean: clean
        rm -rf calculator-client calculator-server</PRE
></TD
></TR
></TABLE
></DIV
> 
</P
><P
>&#13;After calling <B
CLASS="command"
>make</B
> in terminal window
all sources have been compiled and you should open a second terminal
window. In the first window we will start the server with the command:
<B
CLASS="command"
>calculator-server &#62; calculator.ior</B
>. The server
should print a very long string into the file
<TT
CLASS="filename"
>calculator.ior</TT
>, starting with the 4 character
sequence <TT
CLASS="computeroutput"
>IOR:</TT
> In the second window we
start the client with the command <B
CLASS="command"
>calculator-client `cat
calculator.ior` IOR-string</B
>. You should not try to type the
IOR string, instead use the cut and paste functionality of your xterm
or whatever you are using.</P
><P
>&#13;If everything works, you should get the following output:
<TT
CLASS="computeroutput"
>Result: 1.0 + 2.0 = 3</TT
>.
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x278.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x603.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Echo client and server</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c226.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Account Client and Server</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>