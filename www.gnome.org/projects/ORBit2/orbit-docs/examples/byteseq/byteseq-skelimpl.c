/* This is a template file generated by command */
/* orbit-idl-2 --skeleton-impl byteseq.idl */
/* User must edit this file, inserting servant  */
/* specific code between markers. */

#include "byteseq.h"

/*** App-specific servant structures ***/

typedef struct
{
   POA_Examples_ByteSeq_Storage servant;
   PortableServer_POA poa;

   /* ------ add private attributes here ------ */  
   Examples_ByteSeq_Chunk * chunk;
   /* ------ ---------- end ------------ ------ */
} impl_POA_Examples_ByteSeq_Storage;

/*** Implementation stub prototypes ***/

static void
impl_Examples_ByteSeq_Storage__destroy(impl_POA_Examples_ByteSeq_Storage *
				       servant, CORBA_Environment * ev);
static void
impl_Examples_ByteSeq_Storage_set(impl_POA_Examples_ByteSeq_Storage * servant,
				  const Examples_ByteSeq_Chunk * chunk,
				  CORBA_Environment * ev);

static Examples_ByteSeq_Chunk
   *impl_Examples_ByteSeq_Storage_get(impl_POA_Examples_ByteSeq_Storage *
				      servant, CORBA_Environment * ev);

static void
impl_Examples_ByteSeq_Storage_exchange(impl_POA_Examples_ByteSeq_Storage *
				       servant,
				       Examples_ByteSeq_Chunk * chunk,
				       CORBA_Environment * ev);

static
Examples_ByteSeq_Chunk*
chunk_create (CORBA_long maximum)
{
        Examples_ByteSeq_Chunk* chunk = Examples_ByteSeq_Chunk__alloc();
        /* FIXME, handle out of memory */
        chunk->_buffer  = Examples_ByteSeq_Chunk_allocbuf (maximum);
        /* FIXME, handle out of memory */
        chunk->_maximum = maximum;
        chunk->_length  = 0;

	/* lifetime of _buffer corresponds to chunk */
	CORBA_sequence_set_release (chunk, TRUE);

        return chunk;
}

static
void
chunk_exchange (Examples_ByteSeq_Chunk* c, 
		Examples_ByteSeq_Chunk* d)
{
	Examples_ByteSeq_Chunk bucket[1];
	
	bucket->_buffer  = c->_buffer;
	bucket->_maximum = c->_maximum;
	bucket->_length  = c->_length;
	/* do not copy  c->_release */

	c->_buffer  = d->_buffer;
	c->_maximum = d->_maximum;
	c->_length  = d->_length;
	/* keep original c->_release */

	d->_buffer  = bucket->_buffer;
	d->_maximum = bucket->_maximum;
	d->_length  = bucket->_length;
	/* keep original d->_release */
}

static
Examples_ByteSeq_Chunk*
chunk_clone (const Examples_ByteSeq_Chunk* chunk)
{
        CORBA_long i = 0;
	Examples_ByteSeq_Chunk* clone = Examples_ByteSeq_Chunk__alloc ();

        clone->_buffer  = Examples_ByteSeq_Chunk_allocbuf (chunk->_maximum);
	clone->_maximum = chunk->_maximum;
	clone->_length  = chunk->_length;

	/* lifetime of _buffer corresponds to chunk */
	CORBA_sequence_set_release (clone, TRUE);

        for (i=0; i<(chunk->_length); ++i)
        {
                clone->_buffer[i] = chunk->_buffer[i];
        }
                                                                               
        return clone;
}

/*** epv structures ***/

static PortableServer_ServantBase__epv impl_Examples_ByteSeq_Storage_base_epv
   = {
   NULL,			/* _private data */
   (gpointer) & impl_Examples_ByteSeq_Storage__destroy,	/* finalize routine */
   NULL,			/* default_POA routine */
};
static POA_Examples_ByteSeq_Storage__epv impl_Examples_ByteSeq_Storage_epv = {
   NULL,			/* _private */
   (gpointer) & impl_Examples_ByteSeq_Storage_set,

   (gpointer) & impl_Examples_ByteSeq_Storage_get,

   (gpointer) & impl_Examples_ByteSeq_Storage_exchange,

};

/*** vepv structures ***/

static POA_Examples_ByteSeq_Storage__vepv impl_Examples_ByteSeq_Storage_vepv = {
   &impl_Examples_ByteSeq_Storage_base_epv,
   &impl_Examples_ByteSeq_Storage_epv,
};

/*** Stub implementations ***/

static Examples_ByteSeq_Storage
impl_Examples_ByteSeq_Storage__create(PortableServer_POA poa,
				      CORBA_Environment * ev)
{
   Examples_ByteSeq_Storage retval;
   impl_POA_Examples_ByteSeq_Storage *newservant;
   PortableServer_ObjectId *objid;

   newservant = g_new0(impl_POA_Examples_ByteSeq_Storage, 1);
   newservant->servant.vepv = &impl_Examples_ByteSeq_Storage_vepv;
   newservant->poa =
      (PortableServer_POA) CORBA_Object_duplicate((CORBA_Object) poa, ev);
   POA_Examples_ByteSeq_Storage__init((PortableServer_Servant) newservant,
				      ev);
   /* Before servant is going to be activated all
    * private attributes must be initialized.  */

   /* ------ init private attributes here ------ */
   newservant->chunk = chunk_create (1024); /* FIXME, handle out of memory */
   /* ------ ---------- end ------------- ------ */

   objid = PortableServer_POA_activate_object(poa, newservant, ev);
   CORBA_free(objid);
   retval = PortableServer_POA_servant_to_reference(poa, newservant, ev);

   return retval;
}

static void
impl_Examples_ByteSeq_Storage__destroy(impl_POA_Examples_ByteSeq_Storage *
				       servant, CORBA_Environment * ev)
{
   CORBA_Object_release((CORBA_Object) servant->poa, ev);

   /* No further remote method calls are delegated to 
    * servant and you may free your private attributes. */
   /* ------ free private attributes here ------ */
   CORBA_free (servant->chunk);
   /* ------ ---------- end ------------- ------ */

   POA_Examples_ByteSeq_Storage__fini((PortableServer_Servant) servant, ev);
}

static void
impl_Examples_ByteSeq_Storage_set(impl_POA_Examples_ByteSeq_Storage * servant,
				  const Examples_ByteSeq_Chunk * chunk,
				  CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   fprintf (stderr, "!");
 
   CORBA_free (servant->chunk);
   servant->chunk = chunk_clone (chunk);
   /* ------ ---------- end ------------ ------ */
}

static Examples_ByteSeq_Chunk *
impl_Examples_ByteSeq_Storage_get(impl_POA_Examples_ByteSeq_Storage * servant,
				  CORBA_Environment * ev)
{
   Examples_ByteSeq_Chunk *retval;

   /* ------   insert method code here   ------ */
   fprintf (stderr, ".");

   retval = chunk_clone (servant->chunk);
   /* ------ ---------- end ------------ ------ */

   return retval;
}

static void
impl_Examples_ByteSeq_Storage_exchange(impl_POA_Examples_ByteSeq_Storage *
				       servant,
				       Examples_ByteSeq_Chunk * chunk,
				       CORBA_Environment * ev)
{
   /* ------   insert method code here   ------ */
   fprintf (stderr, "#");

   chunk_exchange (servant->chunk, chunk);
   /* ------ ---------- end ------------ ------ */
}
